<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RT0B6NXFG6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RT0B6NXFG6');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waterfall Analysis Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- D3.js with multiple CDN fallbacks -->
    <script>
        function loadD3Script() {
            return new Promise((resolve, reject) => {
                // Try primary CDN first
                const script1 = document.createElement('script');
                script1.src = 'https://d3js.org/d3.v7.min.js';
                script1.onload = () => {
                    console.log('D3.js loaded from d3js.org');
                    resolve();
                };
                script1.onerror = () => {
                    console.log('Trying fallback CDN for D3.js...');
                    // Fallback to jsDelivr
                    const script2 = document.createElement('script');
                    script2.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
                    script2.onload = () => {
                        console.log('D3.js loaded from jsDelivr');
                        resolve();
                    };
                    script2.onerror = () => {
                        console.log('Trying second fallback CDN for D3.js...');
                        // Second fallback to unpkg
                        const script3 = document.createElement('script');
                        script3.src = 'https://unpkg.com/d3@7/dist/d3.min.js';
                        script3.onload = () => {
                            console.log('D3.js loaded from unpkg');
                            resolve();
                        };
                        script3.onerror = () => {
                            console.error('Failed to load D3.js from all CDNs');
                            reject(new Error('D3.js failed to load'));
                        };
                        document.head.appendChild(script3);
                    };
                    document.head.appendChild(script2);
                };
                document.head.appendChild(script1);
            });
        }

        function loadD3SankeyScript() {
            return new Promise((resolve, reject) => {
                // Try primary CDN first
                const script1 = document.createElement('script');
                script1.src = 'https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js';
                script1.onload = () => {
                    console.log('D3-Sankey loaded from unpkg');
                    resolve();
                };
                script1.onerror = () => {
                    console.log('Trying fallback CDN for D3-Sankey...');
                    // Fallback to jsDelivr
                    const script2 = document.createElement('script');
                    script2.src = 'https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js';
                    script2.onload = () => {
                        console.log('D3-Sankey loaded from jsDelivr');
                        resolve();
                    };
                    script2.onerror = () => {
                        console.error('Failed to load D3-Sankey from all CDNs');
                        reject(new Error('D3-Sankey failed to load'));
                    };
                    document.head.appendChild(script2);
                };
                document.head.appendChild(script1);
            });
        }

        // Load scripts sequentially with better error handling
        window.d3LoadPromise = loadD3Script().then(() => {
            return loadD3SankeyScript();
        }).catch(error => {
            console.error('Failed to load D3 libraries:', error);
            // Mark as failed so we can show error immediately
            window.d3LoadFailed = true;
            throw error;
        });

        // Add a timeout fallback
        setTimeout(() => {
            if (typeof d3 === 'undefined' || typeof d3.sankey === 'undefined') {
                console.error('D3 libraries failed to load within timeout');
                window.d3LoadFailed = true;
            }
        }, 10000); // 10 second timeout
    </script>
    <style>
        /* General styles - body styles moved to navbar section */
        
        h1, h2, h3 {
            margin-top: 0;
            color: #111;
        }
        
        h1 { font-size: 1.75rem; margin-bottom: 1rem; }
        h2 { font-size: 1.25rem; margin-bottom: 0.75rem; }
        h3 { font-size: 1rem; margin-bottom: 0.5rem; }
        
        /* Card styles */
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        /* Form elements */
        input, select, button {
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            background-color: white;
        }
        
        input[type="number"] { width: 100px; }
        select { min-width: 150px; background-color: white; }
        
        button {
            background-color: #3b82f6;
            color: white;
            border: none;
            cursor: pointer;
            padding: 8px 16px;
            margin-top: 8px;
        }
        
        button:hover { background-color: #2563eb; }
        
        button.delete {
            background-color: #ef4444;
            padding: 4px 8px;
            font-size: 12px;
        }
        
        button.delete:hover { background-color: #dc2626; }
        
        /* Form layouts */
        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 1rem;
        }
        
        .form-field {
            flex: 1;
            min-width: 200px;
        }
        
        label {
            display: block;
            font-size: 14px;
            margin-bottom: 4px;
            font-weight: 500;
        }
        
        /* Vertical layout */
        .section {
            margin-bottom: 1.5rem;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 14px;
        }
        
        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            white-space: nowrap;
        }
        
        th { font-weight: 600; }
        
        /* Compact table inputs */
        table input, table select {
            width: 100%;
            min-width: 80px;
            padding: 4px 6px;
            font-size: 13px;
        }
        
        /* Specific column widths */
        #shareClassesTable th:nth-child(1), #shareClassesTable td:nth-child(1) { width: 12%; } /* Name */
        #shareClassesTable th:nth-child(2), #shareClassesTable td:nth-child(2) { width: 12%; } /* Type */
        #shareClassesTable th:nth-child(3), #shareClassesTable td:nth-child(3) { width: 10%; } /* Seniority */
        #shareClassesTable th:nth-child(4), #shareClassesTable td:nth-child(4) { width: 12%; } /* Liquidation Pref */
        #shareClassesTable th:nth-child(5), #shareClassesTable td:nth-child(5) { width: 12%; } /* Pref Type */
        #shareClassesTable th:nth-child(6), #shareClassesTable td:nth-child(6) { width: 10%; } /* Cap */
        #shareClassesTable th:nth-child(7), #shareClassesTable td:nth-child(7) { width: 10%; } /* Actions */
        
        #transactionsTable th:nth-child(1), #transactionsTable td:nth-child(1) { width: 15%; } /* Share Class */
        #transactionsTable th:nth-child(2), #transactionsTable td:nth-child(2) { width: 35%; } /* Stakeholder */
        #transactionsTable th:nth-child(3), #transactionsTable td:nth-child(3) { width: 15%; } /* Shares */
        #transactionsTable th:nth-child(4), #transactionsTable td:nth-child(4) { width: 15%; } /* Investment */
        #transactionsTable th:nth-child(5), #transactionsTable td:nth-child(5) { width: 10%; } /* Actions */
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            table input, table select {
                min-width: 60px;
                font-size: 12px;
            }
            
            th, td {
                padding: 0.4rem 0.3rem;
            }
        }
        
        @media (max-width: 768px) {
            .overflow-auto {
                max-width: 100vw;
            }
            
            table {
                font-size: 12px;
            }
            
            th, td {
                padding: 0.3rem 0.2rem;
            }
            
            .sankey-container {
                height: 300px;
            }
            
            .chart-container {
                height: 250px;
            }
        }
        
        /* Chart containers */
        .chart-container {
            position: relative;
            height: 300px;
            margin: 1rem 0;
        }

        /* Sankey diagram styles */
        .sankey-container {
            width: 100%;
            height: 400px;
            margin: 1rem 0;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #fafafa;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        .sankey-container svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .sankey-node rect {
            stroke: #000;
            stroke-width: 1;
        }

        .sankey-link {
            fill: none;
            stroke-opacity: 0.6;
        }

        .sankey-link:hover {
            stroke-opacity: 0.8;
        }

        .sankey-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            font-weight: 500;
        }

        .sankey-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        /* Summary section */
        .summary-info {
            font-size: 14px;
            color: #6b7280;
            margin-top: 0.5rem;
        }
        
        .summary-info ul {
            padding-left: 1.5rem;
            margin-top: 0.25rem;
        }
        
        /* Helper classes */
        .text-right { text-align: right; }
        .space-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .overflow-auto { overflow: auto; }
        .font-bold { font-weight: 600; }
        .preferred-only {
            transition: all 0.3s ease;
        }
        .preferred-only.hidden {
            display: none;
        }
        
        /* Add to existing styles */
        .editing-row input, .editing-row select {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .editing-row {
            background-color: #f9fafb;
        }

        .action-buttons {
            display: flex;
            gap: 4px;
        }

        .action-buttons button {
            margin: 0;
            padding: 4px 8px;
            font-size: 12px;
        }

        button.primary {
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
        }

        button.primary:hover {
            background-color: #2563eb;
        }

        button.save {
            background-color: #10b981;
        }

        button.save:hover {
            background-color: #059669;
        }

        button.cancel {
            background-color: #ef4444;
        }

        button.cancel:hover {
            background-color: #dc2626;
        }

        /* Navigation Bar Styles */
        .nav-bar {
            background-color: #3b82f6;
            color: white;
            padding: 15px 40px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 30px;
            margin: 0;
            border: none;
        }

        .nav-bar a {
            display: flex;
            align-items: center;
            text-decoration: none;
            color: white;
            font-weight: 500;
            gap: 12px;
            font-size: 16px;
            transition: opacity 0.2s ease;
        }

        .nav-bar a:hover {
            opacity: 0.8;
        }

        .nav-bar .nav-title {
            margin-left: auto;
            font-weight: 600;
            color: white;
            font-size: 16px;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .nav-bar {
                padding: 15px 20px;
            }
            
            .nav-bar a {
                font-size: 14px;
                gap: 8px;
            }
            
            .nav-bar .nav-title {
                font-size: 14px;
            }
        }
        /* Adjust body to account for fixed navbar */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.5;
            margin: 0;
            padding: 95px 20px 20px;
            color: #333;
            background-color: #f5f7fa;
        }

        @media (max-width: 768px) {
            body {
                padding: 95px 15px 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="nav-bar">
        <a href="home.html">
            <svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20">
                <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/>
            </svg>
            Home
        </a>
        <span class="nav-title">Waterfall Analysis Tool</span>
    </nav>

    <h1>Waterfall Analysis Tool</h1>
    
    <!-- Share Classes Management -->
    <div class="card section">
        <div class="space-between">
            <h2>Share Classes</h2>
            <button id="addShareClassBtn" class="primary">+ Add Share Class</button>
        </div>
        
        <div class="overflow-auto">
            <table id="shareClassesTable">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Seniority</th>
                        <th>Liquidation Pref</th>
                        <th>Pref Type</th>
                        <th>Cap</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <!-- Transactions Management -->
    <div class="card section">
        <div class="space-between">
            <h2>Transactions</h2>
            <button id="addTransactionBtn" class="primary">+ Add Transaction</button>
        </div>
        
        <div class="overflow-auto">
            <table id="transactionsTable">
                <thead>
                    <tr>
                        <th>Share Class</th>
                        <th>Stakeholder</th>
                        <th>Shares</th>
                        <th>Investment</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <!-- Waterfall Analysis Results -->
    <div class="card section">
        <div class="space-between">
            <h2>Waterfall Results</h2>
            <div>
                <label for="exitAmount">Exit Amount ($)</label>
                <input id="exitAmount" type="number" min="0" value="10000000">
            </div>
        </div>
        
        <!-- Summary Table -->
        <div>
            <h3>Distribution Summary</h3>
            <div class="overflow-auto">
                <table id="summaryTable">
                    <thead>
                        <tr>
                            <th>Share Class</th>
                            <th>Amount ($)</th>
                            <th>Percentage</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <!-- Combined Distribution Chart -->
        <div>
            <h3>Distribution Breakdown</h3>
            <div class="chart-container">
                <canvas id="combinedChart"></canvas>
            </div>
        </div>
        
        <!-- Sankey Flow Diagram -->
        <div>
            <h3>Distribution Flow Diagram</h3>
            <div class="sankey-container">
                <svg id="sankeyDiagram"></svg>
            </div>
        </div>
        
        <!-- Exit Value Distribution Chart -->
        <div>
            <h3>Exit Value Sensitivity Analysis</h3>
            <div class="chart-container">
                <canvas id="exitDistributionChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // State management
        const DEFAULT_SHARE_CLASSES = [
            { id: 1, name: "Series A", type: "preferred", seniority: 1, liquidationPref: 1, prefType: "participating", cap: null },
            { id: 2, name: "Series B", type: "preferred", seniority: 2, liquidationPref: 1.5, prefType: "participating", cap: 3 },
            { id: 3, name: "Series C", type: "common", seniority: 3, liquidationPref: 1, prefType: "non-participating", cap: null }
        ];
        
        const DEFAULT_TRANSACTIONS = [
            { id: 1, shareClass: "Series A", shares: 1000000, investment: 1000000, stakeholder: "Venture Capital Fund LP" },
            { id: 2, shareClass: "Series B", shares: 2000000, investment: 2000000, stakeholder: "Growth Equity Partners" },
            { id: 3, shareClass: "Series C", shares: 750000, investment: 0, stakeholder: "John Smith (Founder)" },
            { id: 4, shareClass: "Series C", shares: 200000, investment: 0, stakeholder: "Jane Doe (Employee)" },
            { id: 5, shareClass: "Series C", shares: 300000, investment: 0, stakeholder: "Mike Johnson (CTO)" }
        ];

        let shareClasses = [...DEFAULT_SHARE_CLASSES];
        let transactions = [...DEFAULT_TRANSACTIONS];
        let exitAmount = 10000000;
        
        // Default stakeholder options for dropdown
        const DEFAULT_STAKEHOLDERS = [
            "John Smith (Founder)",
            "Jane Doe (Employee)", 
            "Mike Johnson (CTO)",
            "Sarah Wilson (COO)",
            "David Brown (VP Engineering)",
            "Lisa Garcia (Head of Product)",
            "Venture Capital Fund LP",
            "Growth Equity Partners",
            "Strategic Investor Corp",
            "Angel Investor Group",
            "Family Office Investment",
            "Employee Stock Option Pool"
        ];
        
        // Charts
        let summaryChart = null;
        let exitDistributionChart = null;
        
        // DOM Elements
        const shareClassesTableBody = document.querySelector('#shareClassesTable tbody');
        const transactionsTableBody = document.querySelector('#transactionsTable tbody');
        const summaryTableBody = document.querySelector('#summaryTable tbody');
        const txShareClassSelect = document.querySelector('#txShareClass');
        
        // Make functions globally accessible for onclick handlers
        window.deleteShareClass = function(id) {
            const shareClass = shareClasses.find(sc => sc.id === id);
            shareClasses = shareClasses.filter(sc => sc.id !== id);
            transactions = transactions.filter(tx => tx.shareClass !== shareClass.name);
            
            renderShareClasses();
            renderTransactions();
            updateWaterfallAnalysis();
        };
        
        window.deleteTransaction = function(id) {
            transactions = transactions.filter(tx => tx.id !== id);
            
            renderTransactions();
            updateWaterfallAnalysis();
        };
        
        // Reset to default data
        function resetToDefault() {
            shareClasses = [...DEFAULT_SHARE_CLASSES];
            transactions = [...DEFAULT_TRANSACTIONS];
            exitAmount = 10000000;
            document.getElementById('exitAmount').value = exitAmount;
            
            renderShareClasses();
            renderTransactions();
            updateWaterfallAnalysis();
        }

        // Initialize the application
        function init() {
            // Event listeners for add buttons
            document.getElementById('addShareClassBtn').addEventListener('click', addNewShareClassRow);
            document.getElementById('addTransactionBtn').addEventListener('click', addNewTransactionRow);
            document.getElementById('exitAmount').addEventListener('input', updateExitAmount);
            
            // Add window resize listener for responsive Sankey diagram
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Only redraw if the sankey diagram exists
                    if (document.getElementById('sankeyDiagram').children.length > 0) {
                        updateWaterfallAnalysis();
                    }
                }, 250); // Debounce resize events
            });
            
            // Load default data and wait for D3 if needed
            resetToDefault();
            
            // Ensure D3 is loaded before initial render
            if (window.d3LoadPromise) {
                window.d3LoadPromise.then(() => {
                    console.log('D3 fully loaded, updating waterfall analysis...');
                    // Small delay to ensure DOM is ready
                    setTimeout(updateWaterfallAnalysis, 200);
                }).catch((error) => {
                    console.error('D3 failed to load during init:', error);
                });
            }
        }
        
        // Update exit amount
        function updateExitAmount() {
            exitAmount = parseFloat(document.getElementById('exitAmount').value) || 0;
            updateWaterfallAnalysis();
        }
        
        // Render share classes to the table
        function renderShareClasses() {
            shareClassesTableBody.innerHTML = '';
            
            shareClasses.forEach(sc => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td><input type="text" class="name" value="${sc.name}" onchange="updateShareClass(${sc.id}, this)"></td>
                    <td>
                        <select class="type" onchange="updateShareClass(${sc.id}, this)">
                            <option value="preferred" ${sc.type === 'preferred' ? 'selected' : ''}>Preferred</option>
                            <option value="common" ${sc.type === 'common' ? 'selected' : ''}>Common</option>
                        </select>
                    </td>
                    <td><input type="number" class="seniority" min="1" value="${sc.seniority}" onchange="updateShareClass(${sc.id}, this)"></td>
                    <td>
                        <input type="number" class="liquidationPref" min="1" step="0.1" value="${sc.liquidationPref}" 
                        onchange="updateShareClass(${sc.id}, this)" 
                        style="display: ${sc.type === 'preferred' ? 'block' : 'none'}">
                    </td>
                    <td>
                        <select class="prefType" onchange="updateShareClass(${sc.id}, this)" 
                        style="display: ${sc.type === 'preferred' ? 'block' : 'none'}">
                            <option value="non-participating" ${sc.prefType === 'non-participating' ? 'selected' : ''}>Non-Part.</option>
                            <option value="participating" ${sc.prefType === 'participating' ? 'selected' : ''}>Part.</option>
                        </select>
                    </td>
                    <td>
                        <input type="number" class="cap" min="0" step="0.1" 
                        value="${sc.cap || ''}" placeholder="No cap"
                        onchange="updateShareClass(${sc.id}, this)"
                        style="display: ${sc.type === 'preferred' && sc.prefType === 'participating' ? 'block' : 'none'}">
                    </td>
                    <td><button class="delete" onclick="deleteShareClass(${sc.id})">Delete</button></td>
                `;
                
                // Add type change handler
                const typeSelect = row.querySelector('.type');
                const prefFields = [row.querySelector('.liquidationPref'), row.querySelector('.prefType')];
                const capField = row.querySelector('.cap');
                
                typeSelect.addEventListener('change', function() {
                    const isPreferred = this.value === 'preferred';
                    prefFields.forEach(field => {
                        field.style.display = isPreferred ? 'block' : 'none';
                    });
                    capField.style.display = 
                        (isPreferred && row.querySelector('.prefType').value === 'participating') ? 'block' : 'none';
                });

                // Add preference type change handler
                row.querySelector('.prefType')?.addEventListener('change', function() {
                    if (typeSelect.value === 'preferred') {
                        capField.style.display = 
                            this.value === 'participating' ? 'block' : 'none';
                    }
                });
                
                shareClassesTableBody.appendChild(row);
            });
        }
        
        // Render transactions to the table
        function renderTransactions() {
            transactionsTableBody.innerHTML = '';
            
            transactions.forEach(tx => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>
                        <select class="shareClass" onchange="updateTransaction(${tx.id}, this)">
                            ${shareClasses.map(sc => 
                                `<option value="${sc.name}" ${tx.shareClass === sc.name ? 'selected' : ''}>${sc.name}</option>`
                            ).join('')}
                        </select>
                    </td>
                    <td>
                        <input type="text" class="stakeholder" value="${tx.stakeholder || ''}" 
                        placeholder="Enter stakeholder name" list="stakeholder-options-${tx.id}"
                        onchange="updateTransaction(${tx.id}, this)" oninput="updateTransaction(${tx.id}, this)">
                        <datalist id="stakeholder-options-${tx.id}">
                            ${DEFAULT_STAKEHOLDERS.map(stakeholder => 
                                `<option value="${stakeholder}">`
                            ).join('')}
                        </datalist>
                    </td>
                    <td>
                        <input type="number" class="shares" min="0" value="${tx.shares}" 
                        onchange="updateTransaction(${tx.id}, this)">
                    </td>
                    <td>
                        <input type="number" class="investment" min="0" value="${tx.investment}" 
                        onchange="updateTransaction(${tx.id}, this)">
                    </td>
                    <td><button class="delete" onclick="deleteTransaction(${tx.id})">Delete</button></td>
                `;
                
                transactionsTableBody.appendChild(row);
            });
        }

        // Update share class
        window.updateShareClass = function(id, element) {
            const shareClass = shareClasses.find(sc => sc.id === id);
            if (!shareClass) return;

            const row = element.closest('tr');
            const type = row.querySelector('.type').value;
            
            shareClass.name = row.querySelector('.name').value.trim();
            shareClass.type = type;
            shareClass.seniority = parseInt(row.querySelector('.seniority').value) || 1;
            
            if (type === 'preferred') {
                shareClass.liquidationPref = parseFloat(row.querySelector('.liquidationPref').value) || 1;
                shareClass.prefType = row.querySelector('.prefType').value;
                const capInput = row.querySelector('.cap').value;
                shareClass.cap = capInput !== '' ? parseFloat(capInput) : null;
            } else {
                shareClass.liquidationPref = 1;
                shareClass.prefType = 'non-participating';
                shareClass.cap = null;
            }

            // Update any transactions that reference this share class
            const oldName = shareClass.name;
            transactions.forEach(tx => {
                if (tx.shareClass === oldName) {
                    tx.shareClass = shareClass.name;
                }
            });

            renderShareClasses();
            renderTransactions();
            updateWaterfallAnalysis();
        };

        // Update transaction
        window.updateTransaction = function(id, element) {
            const transaction = transactions.find(tx => tx.id === id);
            if (!transaction) return;

            const row = element.closest('tr');
            
            transaction.shareClass = row.querySelector('.shareClass').value;
            transaction.stakeholder = row.querySelector('.stakeholder').value.trim();
            transaction.shares = parseFloat(row.querySelector('.shares').value) || 0;
            transaction.investment = parseFloat(row.querySelector('.investment').value) || 0;

            // Only update charts if it's not just a typing event
            if (element.className !== 'stakeholder' || element.type !== 'text') {
                updateWaterfallAnalysis();
            }
        };
        
        // Calculate the detailed waterfall analysis
        function calculateDetailedWaterfall() {
            let results = [];
            let remainingProceeds = exitAmount;
            
            // Start with total proceeds
            results.push({
                name: "Total Exit Proceeds",
                value: exitAmount,
                remainingProceeds: remainingProceeds,
                isStarting: true
            });
            
            if (transactions.length === 0) return results;
            
            // Get active share classes with transactions
            const activeShareClasses = shareClasses.filter(sc => 
                transactions.some(tx => tx.shareClass === sc.name)
            );
            
            // Calculate total ownership percentages
            const totalShares = transactions.reduce((sum, tx) => sum + (parseFloat(tx.shares) || 0), 0);
            const ownershipByClass = {};
            
            transactions.forEach(tx => {
                if (!ownershipByClass[tx.shareClass]) {
                    ownershipByClass[tx.shareClass] = 0;
                }
                ownershipByClass[tx.shareClass] += (parseFloat(tx.shares) || 0) / totalShares;
            });

            // First Round - Liquidation Preferences (only for preferred shares, in order of seniority)
            const preferredClasses = [...activeShareClasses]
                .filter(sc => sc.type === 'preferred')
                .sort((a, b) => b.seniority - a.seniority);

            // Handle preferred shares liquidation preferences first
            for (const sc of preferredClasses) {
                if (remainingProceeds <= 0) break;
                
                const transactionsForClass = transactions.filter(tx => tx.shareClass === sc.name);
                let totalInvestment = transactionsForClass.reduce((sum, tx) => sum + parseFloat(tx.investment || 0), 0);
                
                // Calculate liquidation preference
                let liquidationPrefAmount = totalInvestment * parseFloat(sc.liquidationPref || 1);
                let prefPayout = Math.min(liquidationPrefAmount, remainingProceeds);
                
                if (prefPayout > 0) {
                    results.push({ 
                        name: `${sc.name} (Liquidation Preference)`, 
                        value: -prefPayout,
                        description: `${sc.name} receives liquidation preference of $${prefPayout.toLocaleString()}`,
                        remainingProceeds,
                        shareClass: sc.name
                    });
                    
                    remainingProceeds -= prefPayout;
                }
            }

            // Second Round - Pro-rata distribution among participating preferred and common
            if (remainingProceeds > 0) {
                // Get participating preferred and common classes
                const participatingClasses = [
                    ...preferredClasses.filter(sc => sc.prefType === "participating"),
                    ...activeShareClasses.filter(sc => sc.type === "common")
                ];

                // Calculate total participating shares
                const participatingTotal = participatingClasses.reduce((sum, sc) => 
                    sum + ownershipByClass[sc.name], 0
                );

                if (participatingTotal > 0) {
                    for (const sc of participatingClasses) {
                        const proRataShare = ownershipByClass[sc.name] / participatingTotal;
                        let participationAmount = proRataShare * remainingProceeds;

                        // Apply caps for participating preferred if they exist
                        if (sc.type === 'preferred' && sc.cap) {
                            const transactionsForClass = transactions.filter(tx => tx.shareClass === sc.name);
                            const totalInvestment = transactionsForClass.reduce((sum, tx) => sum + parseFloat(tx.investment || 0), 0);
                            const currentPayout = results
                                .filter(r => r.shareClass === sc.name)
                                .reduce((sum, r) => sum - r.value, 0);
                            
                            const capAmount = totalInvestment * sc.cap;
                            participationAmount = Math.min(participationAmount, capAmount - currentPayout);
                        }

                        if (participationAmount > 0) {
                            const distributionType = sc.type === 'common' ? 'Common Distribution' : 'Participation';
                            results.push({ 
                                name: `${sc.name} (${distributionType})`, 
                                value: -participationAmount,
                                description: `${sc.name} receives ${distributionType.toLowerCase()} of $${participationAmount.toLocaleString()}`,
                                remainingProceeds,
                                shareClass: sc.name
                            });
                            
                            remainingProceeds -= participationAmount;
                        }
                    }
                }
            }

            // If there are still remaining proceeds, distribute them pro-rata among all participating classes
            // (including those that may have hit caps - distribute the remainder)
            if (remainingProceeds > 0.01) { // Using small threshold to avoid floating point issues
                // Get all participating classes (participating preferred + common)
                const allParticipatingClasses = [
                    ...preferredClasses.filter(sc => sc.prefType === "participating"),
                    ...activeShareClasses.filter(sc => sc.type === "common")
                ];

                // Calculate total participating ownership
                const totalParticipatingOwnership = allParticipatingClasses.reduce((sum, sc) => 
                    sum + (ownershipByClass[sc.name] || 0), 0
                );

                if (totalParticipatingOwnership > 0) {
                    // Distribute remaining proceeds pro-rata
                    for (const sc of allParticipatingClasses) {
                        const proRataShare = (ownershipByClass[sc.name] || 0) / totalParticipatingOwnership;
                        let additionalAmount = proRataShare * remainingProceeds;

                        // Check if this class has a cap and adjust if necessary
                        if (sc.type === 'preferred' && sc.cap) {
                            const transactionsForClass = transactions.filter(tx => tx.shareClass === sc.name);
                            const totalInvestment = transactionsForClass.reduce((sum, tx) => sum + parseFloat(tx.investment || 0), 0);
                            const currentPayout = results
                                .filter(r => r.shareClass === sc.name)
                                .reduce((sum, r) => sum - r.value, 0);
                            
                            const capAmount = totalInvestment * sc.cap;
                            const availableCapSpace = capAmount - currentPayout;
                            additionalAmount = Math.min(additionalAmount, Math.max(0, availableCapSpace));
                        }

                        if (additionalAmount > 0.01) { // Only add if meaningful amount
                            const distributionType = sc.type === 'common' ? 'Additional Common' : 'Additional Participation';
                            results.push({ 
                                name: `${sc.name} (${distributionType})`, 
                                value: -additionalAmount,
                                description: `${sc.name} receives additional distribution of $${additionalAmount.toLocaleString()}`,
                                remainingProceeds,
                                shareClass: sc.name
                            });
                            
                            remainingProceeds -= additionalAmount;
                        }
                    }
                }
            }
            
            // Final check: if there are still remaining proceeds due to caps, distribute to common shares only
            if (remainingProceeds > 0.01) {
                const commonClasses = activeShareClasses.filter(sc => sc.type === "common");
                const totalCommonOwnership = commonClasses.reduce((sum, sc) => 
                    sum + (ownershipByClass[sc.name] || 0), 0
                );

                if (totalCommonOwnership > 0) {
                    for (const sc of commonClasses) {
                        const proRataShare = (ownershipByClass[sc.name] || 0) / totalCommonOwnership;
                        const finalAmount = proRataShare * remainingProceeds;

                        if (finalAmount > 0.01) {
                            results.push({ 
                                name: `${sc.name} (Final Distribution)`, 
                                value: -finalAmount,
                                description: `${sc.name} receives final distribution of $${finalAmount.toLocaleString()}`,
                                remainingProceeds,
                                shareClass: sc.name
                            });
                            
                            remainingProceeds -= finalAmount;
                        }
                    }
                }
            }
            
            return results;
        }
        
        // Calculate summary waterfall distribution
        function calculateSummaryWaterfall() {
            const detailedResults = calculateDetailedWaterfall();
            const summaryByClass = {};
            
            // Skip the first "Total Exit Proceeds" entry
            detailedResults.slice(1).forEach(result => {
                if (!result.shareClass) return;
                
                if (!summaryByClass[result.shareClass]) {
                    summaryByClass[result.shareClass] = {
                        name: result.shareClass,
                        payout: 0,
                        components: {
                            'Liquidation Preference': 0,
                            'Participation': 0,
                            'Common Distribution': 0
                        }
                    };
                }
                
                const amount = Math.abs(result.value);
                summaryByClass[result.shareClass].payout += amount;
                
                // Categorize the payment
                if (result.name.includes('Liquidation Preference')) {
                    summaryByClass[result.shareClass].components['Liquidation Preference'] += amount;
                } else if (result.name.includes('Participation') || result.name.includes('Additional Participation')) {
                    summaryByClass[result.shareClass].components['Participation'] += amount;
                } else if (result.name.includes('Common') || result.name.includes('Final Distribution')) {
                    summaryByClass[result.shareClass].components['Common Distribution'] += amount;
                }
            });
            
            return Object.values(summaryByClass).map(summary => ({
                ...summary,
                percentage: Math.round((summary.payout / exitAmount) * 10000) / 100
            }));
        }
        
        // Update the waterfall analysis charts and tables
        function updateWaterfallAnalysis() {
            const waterfallSteps = calculateDetailedWaterfall();
            const summaryData = calculateSummaryWaterfall();
            
            // Update the summary table
            renderSummaryTable(summaryData);
            
            // Update the charts
            renderCombinedChart(waterfallSteps, summaryData);
            renderExitDistributionChart();
            renderSankeyDiagram(waterfallSteps, summaryData);
        }
        
        // Calculate distribution for a specific exit value
        function calculateDistributionAtExit(exitValue) {
            const originalExitAmount = exitAmount;
            exitAmount = exitValue;
            const distribution = calculateSummaryWaterfall();
            exitAmount = originalExitAmount;
            return distribution;
        }
        
        // Render summary table
        function renderSummaryTable(summaryData) {
            // Clear the table
            summaryTableBody.innerHTML = '';
            
            // Add each summary row
            summaryData.forEach(result => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${result.name}</td>
                    <td>$${result.payout.toLocaleString()}</td>
                    <td>${result.percentage}%</td>
                `;
                
                summaryTableBody.appendChild(row);
            });
            
            // Add total row
            const totalRow = document.createElement('tr');
            totalRow.className = 'font-bold';
            
            totalRow.innerHTML = `
                <td>Total</td>
                <td>$${exitAmount.toLocaleString()}</td>
                <td>100%</td>
            `;
            
            summaryTableBody.appendChild(totalRow);
        }
        
        // Render combined chart
        function renderCombinedChart(waterfallSteps, summaryData) {
            const ctx = document.getElementById('combinedChart').getContext('2d');
            
            if (summaryChart) {
                summaryChart.destroy();
            }

            // Group steps by share class and distribution type
            const shareClassSteps = {};
            waterfallSteps.forEach(step => {
                if (step.shareClass && !step.isStarting && !step.isFinal) {
                    if (!shareClassSteps[step.shareClass]) {
                        shareClassSteps[step.shareClass] = {
                            'Liquidation Preference': 0,
                            'Participation': 0,
                            'Common Distribution': 0
                        };
                    }
                    const match = step.name.match(/\((.*?)\)/);
                    if (match) {
                        const type = match[1];
                        if (type === "Liquidation Preference") {
                            shareClassSteps[step.shareClass]["Liquidation Preference"] += Math.abs(step.value);
                        } else if (type.includes("Participation") || type === "Additional Participation") {
                            shareClassSteps[step.shareClass]["Participation"] += Math.abs(step.value);
                        } else if (type.includes("Common") || type === "Final Distribution") {
                            shareClassSteps[step.shareClass]["Common Distribution"] += Math.abs(step.value);
                        }
                    }
                }
            });

            // Create datasets for each distribution type
            const distributionTypes = [
                'Liquidation Preference',
                'Participation',
                'Common Distribution'
            ];
            const datasets = distributionTypes.map(type => ({
                label: type,
                data: summaryData.map(summary => {
                    return shareClassSteps[summary.name]?.[type] || 0;
                }),
                backgroundColor: getDistributionTypeColor(type),
                borderColor: getDistributionTypeColor(type, 0.8),
                borderWidth: 1
            })).filter(dataset => dataset.data.some(value => value > 0)); // Only include datasets with non-zero values

            summaryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: summaryData.map(d => d.name),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const shareClass = context[0].label;
                                    const sc = shareClasses.find(s => s.name === shareClass);
                                    if (!sc) return shareClass;
                                    
                                    let title = shareClass;
                                    if (sc.type === 'preferred') {
                                        title += ` (${sc.prefType})`;
                                        if (sc.prefType === 'participating' && sc.cap) {
                                            title += ` - ${sc.cap}x cap`;
                                        }
                                    }
                                    return title;
                                },
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === 0) return null;
                                    const percentage = ((value / exitAmount) * 100).toFixed(1);
                                    return `${context.dataset.label}: $${value.toLocaleString()} (${percentage}%)`;
                                },
                                afterBody: function(context) {
                                    const shareClass = context[0].label;
                                    const total = datasets.reduce((sum, dataset) => 
                                        sum + (dataset.data[context[0].dataIndex] || 0), 0
                                    );
                                    const percentage = ((total/exitAmount)*100).toFixed(1);
                                    return [`Total Payout: $${total.toLocaleString()} (${percentage}%)`];
                                }
                            }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                boxWidth: 12,
                                padding: 15
                            }
                        }
                    }
                }
            });
        }
        
        // Helper function to get colors for distribution types
        function getDistributionTypeColor(type, alpha = 1) {
            // Use consistent colors for each distribution type
            const colors = {
                'Liquidation Preference': `rgba(59, 130, 246, ${alpha})`, // Blue for liquidation preferences
                'Participation': `rgba(16, 185, 129, ${alpha})`, // Green for participation
                'Common Distribution': `rgba(107, 114, 128, ${alpha})` // Gray for common
            };
            return colors[type] || `rgba(107, 114, 128, ${alpha})`;
        }
        
        // Render exit distribution chart
        function renderExitDistributionChart() {
            const ctx = document.getElementById('exitDistributionChart').getContext('2d');
            
            if (exitDistributionChart) {
                exitDistributionChart.destroy();
            }
            
            // Generate exit values from 0 to 2x current exit amount
            const maxExit = exitAmount * 2;
            const numPoints = 20;
            const exitValues = Array.from({length: numPoints + 1}, (_, i) => (maxExit * i) / numPoints);
            
            // Get all unique share classes
            const activeShareClasses = [...new Set(
                shareClasses
                    .filter(sc => transactions.some(tx => tx.shareClass === sc.name))
                    .map(sc => sc.name)
            )];
            
            // Calculate distributions for each exit value
            const distributions = exitValues.map(exitValue => {
                const dist = calculateDistributionAtExit(exitValue);
                return activeShareClasses.map(className => {
                    const shareData = dist.find(d => d.name === className);
                    return shareData ? shareData.payout : 0;
                });
            });
            
            // Create datasets for each share class
            const datasets = activeShareClasses.map((className, index) => ({
                label: className,
                data: distributions.map(dist => dist[index]),
                fill: true,
                borderColor: getShareClassColor(className, index),
                backgroundColor: getShareClassColor(className, index, 0.1),
                tension: 0.4
            }));
            
            let verticalLineX = null;
            
            exitDistributionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: exitValues.map(value => formatCurrency(value)),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Exit Value'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Distribution Amount'
                            },
                            ticks: {
                                callback: value => formatCurrency(value)
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(tooltipItems) {
                                    return `Exit Value: ${tooltipItems[0].label}`;
                                },
                                label: function(tooltipItem) {
                                    const exitValue = parseFloat(tooltipItem.raw);
                                    const shareClass = tooltipItem.dataset.label;
                                    const distribution = calculateDistributionAtExit(exitValue);
                                    const shareData = distribution.find(d => d.name === shareClass);
                                    
                                    if (!shareData) {
                                        return `${shareClass}: ${formatCurrency(tooltipItem.raw)}`;
                                    }
                                    
                                    const components = shareData.components;
                                    const totalPercentage = ((shareData.payout / exitValue) * 100).toFixed(1);
                                    
                                    let lines = [`${shareClass}: ${formatCurrency(shareData.payout)} (${totalPercentage}%)`];
                                    
                                    if (components['Liquidation Preference'] > 0) {
                                        const prefPercentage = ((components['Liquidation Preference'] / exitValue) * 100).toFixed(1);
                                        lines.push(`  • Liquidation Preference: ${formatCurrency(components['Liquidation Preference'])} (${prefPercentage}%)`);
                                    }
                                    
                                    if (components['Participation'] > 0) {
                                        const partPercentage = ((components['Participation'] / exitValue) * 100).toFixed(1);
                                        lines.push(`  • Participation: ${formatCurrency(components['Participation'])} (${partPercentage}%)`);
                                    }
                                    
                                    if (components['Common Distribution'] > 0) {
                                        const commonPercentage = ((components['Common Distribution'] / exitValue) * 100).toFixed(1);
                                        lines.push(`  • Common Distribution: ${formatCurrency(components['Common Distribution'])} (${commonPercentage}%)`);
                                    }
                                    
                                    return lines;
                                }
                            }
                        }
                    }
                }
            });
            
            // Add mousemove event listener to draw vertical line
            ctx.canvas.addEventListener('mousemove', (event) => {
                const rect = ctx.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                verticalLineX = x;
                
                // Clear the canvas and redraw
                exitDistributionChart.draw();
                
                // Draw vertical line
                if (x >= 0 && x <= ctx.canvas.width) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, ctx.canvas.height);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.8)';
                    ctx.stroke();
                    ctx.restore();
                }
            });
            
            // Add mouseleave event listener to clear vertical line
            ctx.canvas.addEventListener('mouseleave', () => {
                verticalLineX = null;
                exitDistributionChart.draw();
            });
            
            // Override the chart's draw function to maintain the vertical line
            const originalDraw = exitDistributionChart.draw;
            exitDistributionChart.draw = function() {
                originalDraw.apply(this, arguments);
                if (verticalLineX !== null) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(verticalLineX, 0);
                    ctx.lineTo(verticalLineX, ctx.canvas.height);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.8)';
                    ctx.stroke();
                    ctx.restore();
                }
            };
        }
        
        // Helper function to format currency
        function formatCurrency(value) {
            return '$' + value.toLocaleString();
        }
        
        // Helper function to get consistent colors for share classes
        function getShareClassColor(className, index, alpha = 1) {
            const colors = {
                'Common': `rgba(168, 85, 247, ${alpha})`, // Purple
                'Series A': `rgba(59, 130, 246, ${alpha})`, // Blue
                'Series B': `rgba(16, 185, 129, ${alpha})`, // Green
                'Series C': `rgba(245, 158, 11, ${alpha})`, // Orange
                'Series D': `rgba(239, 68, 68, ${alpha})`, // Red
            };
            
            return colors[className] || `hsla(${index * 137.5}, 70%, 50%, ${alpha})`;
        }
        
        // Add new share class row
        function addNewShareClassRow() {
            const row = document.createElement('tr');
            row.className = 'editing-row';
            
            row.innerHTML = `
                <td><input type="text" class="name" placeholder="Series A"></td>
                <td>
                    <select class="type">
                        <option value="preferred">Preferred</option>
                        <option value="common">Common</option>
                    </select>
                </td>
                <td><input type="number" class="seniority" min="1" value="1"></td>
                <td><input type="number" class="liquidationPref" min="1" step="0.1" value="1"></td>
                <td>
                    <select class="prefType">
                        <option value="non-participating">Non-Participating</option>
                        <option value="participating">Participating</option>
                    </select>
                </td>
                <td><input type="number" class="cap" min="0" step="0.1" placeholder="No cap"></td>
                <td class="action-buttons">
                    <button class="save" onclick="saveShareClass(this)">Save</button>
                    <button class="cancel" onclick="cancelShareClass(this)">Cancel</button>
                </td>
            `;

            // Add type change handler
            const typeSelect = row.querySelector('.type');
            const prefFields = [row.querySelector('.liquidationPref'), row.querySelector('.prefType')];
            const capField = row.querySelector('.cap');
            
            typeSelect.addEventListener('change', function() {
                const isPreferred = this.value === 'preferred';
                prefFields.forEach(field => {
                    field.parentElement.style.display = isPreferred ? '' : 'none';
                });
                capField.parentElement.style.display = 
                    (isPreferred && row.querySelector('.prefType').value === 'participating') ? '' : 'none';
            });

            // Add preference type change handler
            row.querySelector('.prefType').addEventListener('change', function() {
                if (typeSelect.value === 'preferred') {
                    capField.parentElement.style.display = 
                        this.value === 'participating' ? '' : 'none';
                }
            });
            
            shareClassesTableBody.appendChild(row);
        }

        // Save share class
        function saveShareClass(button) {
            const row = button.closest('tr');
            const name = row.querySelector('.name').value.trim();
            if (name === '') return;

            const type = row.querySelector('.type').value;
            const seniority = parseInt(row.querySelector('.seniority').value) || 1;
            const liquidationPref = type === 'preferred' ? (parseFloat(row.querySelector('.liquidationPref').value) || 1) : 1;
            const prefType = type === 'preferred' ? row.querySelector('.prefType').value : 'non-participating';
            const capInput = row.querySelector('.cap').value;
            const cap = (type === 'preferred' && capInput !== '') ? parseFloat(capInput) : null;

            const newShareClass = {
                id: shareClasses.length > 0 ? Math.max(...shareClasses.map(sc => sc.id)) + 1 : 1,
                name,
                type,
                seniority,
                liquidationPref,
                prefType,
                cap
            };

            shareClasses.push(newShareClass);
            renderShareClasses();
            updateWaterfallAnalysis();
        }

        // Cancel share class addition
        function cancelShareClass(button) {
            const row = button.closest('tr');
            row.remove();
        }

        // Add new transaction row
        function addNewTransactionRow() {
            const row = document.createElement('tr');
            row.className = 'editing-row';
            
            const tempId = Date.now(); // Temporary ID for datalist
            
            row.innerHTML = `
                <td>
                    <select class="shareClass">
                        <option value="">Select Class</option>
                        ${shareClasses.map(sc => `<option value="${sc.name}">${sc.name}</option>`).join('')}
                    </select>
                </td>
                <td>
                    <input type="text" class="stakeholder" placeholder="Enter stakeholder name" list="stakeholder-options-new-${tempId}">
                    <datalist id="stakeholder-options-new-${tempId}">
                        ${DEFAULT_STAKEHOLDERS.map(stakeholder => 
                            `<option value="${stakeholder}">`
                        ).join('')}
                    </datalist>
                </td>
                <td><input type="number" class="shares" min="0" value="0"></td>
                <td><input type="number" class="investment" min="0" value="0"></td>
                <td class="action-buttons">
                    <button class="save" onclick="saveTransaction(this)">Save</button>
                    <button class="cancel" onclick="cancelTransaction(this)">Cancel</button>
                </td>
            `;
            
            transactionsTableBody.appendChild(row);
        }

        // Save transaction
        function saveTransaction(button) {
            const row = button.closest('tr');
            const shareClass = row.querySelector('.shareClass').value;
            if (shareClass === '') return;

            const stakeholder = row.querySelector('.stakeholder').value.trim();
            const shares = parseFloat(row.querySelector('.shares').value) || 0;
            const investment = parseFloat(row.querySelector('.investment').value) || 0;

            const newTransaction = {
                id: transactions.length > 0 ? Math.max(...transactions.map(tx => tx.id)) + 1 : 1,
                shareClass,
                stakeholder,
                shares,
                investment
            };

            transactions.push(newTransaction);
            renderTransactions();
            updateWaterfallAnalysis();
        }

        // Cancel transaction addition
        function cancelTransaction(button) {
            const row = button.closest('tr');
            row.remove();
        }

        // Render Sankey Diagram
        function renderSankeyDiagram(waterfallSteps, summaryData) {
            // Check if loading already failed
            if (window.d3LoadFailed) {
                showSankeyError();
                return;
            }
            
            // Check if D3 is available
            if (typeof d3 === 'undefined' || typeof d3.sankey === 'undefined') {
                console.log('D3.js or D3-Sankey not yet loaded, waiting...');
                
                // Show loading message
                const sankeyContainer = document.querySelector('.sankey-container');
                sankeyContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-size: 14px;">
                        <div>
                            <div style="margin-bottom: 10px;">Loading Sankey diagram...</div>
                            <div style="width: 200px; height: 4px; background: #e5e7eb; border-radius: 2px; overflow: hidden;">
                                <div style="width: 100%; height: 100%; background: linear-gradient(90deg, #3b82f6 0%, #8b5cf6 100%); animation: loading 1.5s ease-in-out infinite;"></div>
                            </div>
                        </div>
                    </div>
                    <style>
                        @keyframes loading {
                            0% { transform: translateX(-100%); }
                            100% { transform: translateX(100%); }
                        }
                    </style>
                `;
                
                // Wait for D3 libraries to load
                if (window.d3LoadPromise) {
                    window.d3LoadPromise.then(() => {
                        console.log('D3 libraries loaded, rendering Sankey...');
                        setTimeout(() => renderSankeyDiagram(waterfallSteps, summaryData), 100);
                    }).catch((error) => {
                        console.error('Failed to load D3 libraries:', error);
                        showSankeyError();
                    });
                } else {
                    // Fallback: try again after a short delay with timeout
                    setTimeout(() => {
                        if (typeof d3 !== 'undefined' && typeof d3.sankey !== 'undefined') {
                            renderSankeyDiagram(waterfallSteps, summaryData);
                        } else if (!window.d3LoadFailed) {
                            console.log('Still waiting for D3, trying once more...');
                            setTimeout(() => {
                                if (typeof d3 !== 'undefined' && typeof d3.sankey !== 'undefined') {
                                    renderSankeyDiagram(waterfallSteps, summaryData);
                                } else {
                                    console.error('D3 loading timeout exceeded');
                                    window.d3LoadFailed = true;
                                    showSankeyError();
                                }
                            }, 3000);
                        } else {
                            showSankeyError();
                        }
                    }, 1500);
                }
                return;
            }
            
            // Clear existing diagram
            d3.select("#sankeyDiagram").selectAll("*").remove();
            
            const container = document.querySelector('.sankey-container');
            const containerRect = container.getBoundingClientRect();
            
            // Responsive margins based on screen size
            const isMobile = window.innerWidth < 768;
            const isTablet = window.innerWidth < 1024;
            
            const margin = {
                top: isMobile ? 15 : 20,
                right: isMobile ? 10 : (isTablet ? 15 : 20),
                bottom: isMobile ? 15 : 20,
                left: isMobile ? 10 : (isTablet ? 15 : 20)
            };
            
            const width = Math.max(300, containerRect.width - margin.left - margin.right);
            const height = Math.max(200, containerRect.height - margin.top - margin.bottom);
            
            // Create SVG with responsive viewBox
            const svg = d3.select("#sankeyDiagram")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr("preserveAspectRatio", "xMidYMid meet")
                .style("width", "100%")
                .style("height", "100%");
                
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create tooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "sankey-tooltip")
                .style("opacity", 0);

            // Prepare data for Sankey
            const nodes = [];
            const links = [];
            
            // Node indices
            let nodeIndex = 0;
            
            // Source node (Exit Amount)
            nodes.push({ name: "Exit Amount", id: nodeIndex++, layer: 0 });
            const exitNodeIndex = 0;
            
            // Share class nodes (Layer 1)
            const shareClassNodes = {};
            shareClasses.forEach(sc => {
                shareClassNodes[sc.name] = nodeIndex;
                nodes.push({ 
                    name: sc.name, 
                    id: nodeIndex++, 
                    layer: 1,
                    type: sc.type,
                    shareClass: sc
                });
            });
            
            // Transaction nodes (Layer 2) - Individual transactions within each share class
            const transactionNodes = {};
            transactions.forEach(tx => {
                const txKey = `${tx.shareClass}_tx_${tx.id}`;
                transactionNodes[txKey] = nodeIndex;
                const stakeholderName = tx.stakeholder ? tx.stakeholder.split(' ')[0] + (tx.stakeholder.includes('(') ? ` ${tx.stakeholder.match(/\((.*?)\)/)?.[1] || ''}` : '') : 'Unknown';
                nodes.push({ 
                    name: `${stakeholderName}`, 
                    id: nodeIndex++, 
                    layer: 2,
                    transaction: tx,
                    shareClassName: tx.shareClass
                });
            });
            
            // Distribution mechanism nodes (Layer 3)
            const distributionNodes = {};
            const distributionTypes = ['Liquidation Preference', 'Participation', 'Common Distribution'];
            distributionTypes.forEach(type => {
                distributionNodes[type] = nodeIndex;
                nodes.push({ 
                    name: type, 
                    id: nodeIndex++, 
                    layer: 3,
                    distributionType: type
                });
            });
            
            // Final distribution nodes (Layer 4)
            const finalNodes = {};
            summaryData.forEach(summary => {
                if (summary.payout > 0) {
                    finalNodes[summary.name] = nodeIndex;
                    nodes.push({ 
                        name: `${summary.name} Final`, 
                        id: nodeIndex++, 
                        layer: 4,
                        finalAmount: summary.payout
                    });
                }
            });

            // Create links from Exit Amount to Share Classes
            shareClasses.forEach(sc => {
                const scSummary = summaryData.find(s => s.name === sc.name);
                if (scSummary && scSummary.payout > 0) {
                    links.push({
                        source: exitNodeIndex,
                        target: shareClassNodes[sc.name],
                        value: scSummary.payout
                    });
                }
            });

            // Create links from Share Classes to Individual Transactions
            transactions.forEach(tx => {
                const txKey = `${tx.shareClass}_tx_${tx.id}`;
                const scSummary = summaryData.find(s => s.name === tx.shareClass);
                
                if (scSummary && scSummary.payout > 0) {
                    // Calculate transaction's share of the total payout for this share class
                    const totalSharesInClass = transactions
                        .filter(t => t.shareClass === tx.shareClass)
                        .reduce((sum, t) => sum + t.shares, 0);
                    
                    const transactionPortion = totalSharesInClass > 0 ? 
                        (tx.shares / totalSharesInClass) * scSummary.payout : 0;
                    
                    if (transactionPortion > 0) {
                        links.push({
                            source: shareClassNodes[tx.shareClass],
                            target: transactionNodes[txKey],
                            value: transactionPortion
                        });
                    }
                }
            });

            // Create links from Transactions to Distribution Types
            const distributionData = {};
            const transactionDistributionData = {};
            
            waterfallSteps.forEach(step => {
                if (step.shareClass && !step.isStarting && !step.isFinal && step.value > 0) {
                    const match = step.name.match(/\((.*?)\)/);
                    if (match) {
                        let type = match[1];
                        if (type === "Liquidation Preference") {
                            type = "Liquidation Preference";
                        } else if (type.includes("Participation") || type === "Additional Participation") {
                            type = "Participation";
                        } else if (type.includes("Common")) {
                            type = "Common Distribution";
                        } else {
                            return; // Skip unknown types
                        }
                        
                        if (!distributionData[step.shareClass]) {
                            distributionData[step.shareClass] = {};
                        }
                        if (!distributionData[step.shareClass][type]) {
                            distributionData[step.shareClass][type] = 0;
                        }
                        distributionData[step.shareClass][type] += Math.abs(step.value);
                    }
                }
            });

            // Distribute the distribution amounts across transactions proportionally
            transactions.forEach(tx => {
                const txKey = `${tx.shareClass}_tx_${tx.id}`;
                const totalSharesInClass = transactions
                    .filter(t => t.shareClass === tx.shareClass)
                    .reduce((sum, t) => sum + t.shares, 0);
                
                if (totalSharesInClass > 0 && distributionData[tx.shareClass]) {
                    const transactionProportion = tx.shares / totalSharesInClass;
                    
                    Object.keys(distributionData[tx.shareClass]).forEach(distType => {
                        const value = distributionData[tx.shareClass][distType] * transactionProportion;
                        if (value > 0) {
                            links.push({
                                source: transactionNodes[txKey],
                                target: distributionNodes[distType],
                                value: value
                            });
                        }
                    });
                }
            });

            // Add links from distribution mechanisms to final amounts
            Object.keys(distributionData).forEach(shareClassName => {
                const totalForClass = Object.values(distributionData[shareClassName]).reduce((sum, val) => sum + val, 0);
                if (totalForClass > 0 && finalNodes[shareClassName] !== undefined) {
                    Object.keys(distributionData[shareClassName]).forEach(distType => {
                        const value = distributionData[shareClassName][distType];
                        if (value > 0) {
                            links.push({
                                source: distributionNodes[distType],
                                target: finalNodes[shareClassName],
                                value: value
                            });
                        }
                    });
                }
            });

            // Create Sankey layout with responsive parameters
            const nodeWidth = isMobile ? 8 : (isTablet ? 10 : 12);
            const nodePadding = isMobile ? 5 : (isTablet ? 6 : 8);
            
            const sankey = d3.sankey()
                .nodeId(d => d.id)
                .nodeWidth(nodeWidth)
                .nodePadding(nodePadding)
                .extent([[1, 5], [width - 1, height - 5]]);

            const { nodes: sankeyNodes, links: sankeyLinks } = sankey({
                nodes: nodes.map(d => ({ ...d })),
                links: links.map(d => ({ ...d }))
            });

            // Enhanced color scale
            const colorScale = d3.scaleOrdinal()
                .domain(['preferred', 'common', 'Liquidation Preference', 'Participation', 'Common Distribution', 'transaction'])
                .range(['#3b82f6', '#8b5cf6', '#ef4444', '#10b981', '#6b7280', '#f59e0b']);

            // Draw links
            g.append("g")
                .selectAll("path")
                .data(sankeyLinks)
                .join("path")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", d => {
                    if (d.source.layer === 0) return '#94a3b8'; // Exit amount
                    if (d.source.layer === 1) return colorScale(d.source.type || 'common'); // Share classes
                    if (d.source.layer === 2) return colorScale('transaction'); // Transactions
                    if (d.source.layer === 3) return colorScale(d.source.distributionType); // Distribution types
                    return '#94a3b8';
                })
                .attr("stroke-width", d => Math.max(1, d.width))
                .style("mix-blend-mode", "multiply")
                .attr("class", "sankey-link")
                .on("mouseover", function(event, d) {
                    const percentage = ((d.value / exitAmount) * 100).toFixed(1);
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    
                    let flowDescription = "";
                    if (d.source.layer === 0) flowDescription = "Exit proceeds to share class";
                    else if (d.source.layer === 1) flowDescription = "Share class to transaction";
                    else if (d.source.layer === 2) flowDescription = "Transaction to distribution mechanism";
                    else if (d.source.layer === 3) flowDescription = "Distribution mechanism to final payout";
                    
                    tooltip.html(`
                        <strong>${d.source.name} → ${d.target.name}</strong><br/>
                        ${flowDescription}<br/>
                        Amount: $${d.value.toLocaleString()}<br/>
                        Percentage: ${percentage}%
                    `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Draw nodes
            g.append("g")
                .selectAll("rect")
                .data(sankeyNodes)
                .join("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", d => {
                    if (d.layer === 0) return '#1e293b'; // Exit amount
                    if (d.layer === 1) return colorScale(d.type || 'common'); // Share classes
                    if (d.layer === 2) return colorScale('transaction'); // Transactions
                    if (d.layer === 3) return colorScale(d.distributionType); // Distribution types
                    if (d.layer === 4) return colorScale(d.name.split(' ')[0]); // Final amounts
                    return '#94a3b8';
                })
                .attr("class", "sankey-node")
                .on("mouseover", function(event, d) {
                    let content = `<strong>${d.name}</strong><br/>`;
                    if (d.layer === 0) {
                        content += `Total Exit Amount: $${exitAmount.toLocaleString()}`;
                    } else if (d.layer === 1 && d.shareClass) {
                        content += `Share Class Type: ${d.shareClass.type}<br/>`;
                        if (d.shareClass.type === 'preferred') {
                            content += `Liquidation Pref: ${d.shareClass.liquidationPref}x<br/>`;
                            content += `${d.shareClass.prefType}`;
                            if (d.shareClass.cap) content += ` (${d.shareClass.cap}x cap)`;
                        }
                        const totalShares = transactions
                            .filter(t => t.shareClass === d.shareClass.name)
                            .reduce((sum, t) => sum + t.shares, 0);
                        content += `<br/>Total Shares: ${totalShares.toLocaleString()}`;
                    } else if (d.layer === 2 && d.transaction) {
                        content += `Transaction Details:<br/>`;
                        content += `Shares: ${d.transaction.shares.toLocaleString()}<br/>`;
                        content += `Investment: $${d.transaction.investment.toLocaleString()}<br/>`;
                        const pricePerShare = d.transaction.shares > 0 ? d.transaction.investment / d.transaction.shares : 0;
                        content += `Price/Share: $${pricePerShare.toFixed(2)}`;
                    } else if (d.layer === 3) {
                        content += `Distribution Mechanism<br/>`;
                        content += `Used across all applicable transactions`;
                    } else if (d.layer === 4) {
                        content += `Final Payout: $${d.finalAmount.toLocaleString()}<br/>`;
                        const percentage = ((d.finalAmount / exitAmount) * 100).toFixed(1);
                        content += `Percentage of Total: ${percentage}%`;
                    }
                    
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(content)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Add node labels with responsive sizing
            const labelOffset = isMobile ? 4 : 6;
            const baseFontSize = isMobile ? 9 : (isTablet ? 10 : 12);
            const smallFontSize = isMobile ? 8 : (isTablet ? 9 : 10);
            
            g.append("g")
                .selectAll("text")
                .data(sankeyNodes)
                .join("text")
                .attr("x", d => d.x0 < width / 2 ? d.x1 + labelOffset : d.x0 - labelOffset)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
                .attr("class", "sankey-text")
                .text(d => {
                    if (d.layer === 0) return `$${(exitAmount/1000000).toFixed(1)}M`;
                    if (d.layer === 2 && d.transaction) {
                        // Responsive text based on screen size
                        if (isMobile) {
                            // On mobile, show shorter labels
                            const shareText = d.transaction.shares >= 1000000 ? 
                                `${(d.transaction.shares/1000000).toFixed(1)}M` : 
                                `${(d.transaction.shares/1000).toFixed(0)}K`;
                            return shareText;
                        } else {
                            const shareText = d.transaction.shares >= 1000000 ? 
                                `${(d.transaction.shares/1000000).toFixed(1)}M` : 
                                d.transaction.shares.toLocaleString();
                            return `${shareText} shares`;
                        }
                    }
                    if (d.layer === 4) return `$${(d.finalAmount/1000000).toFixed(1)}M`;
                    
                    // Truncate long names on mobile
                    if (isMobile && d.name.length > 12) {
                        return d.name.substring(0, 10) + "...";
                    }
                    return d.name;
                })
                .attr("fill", "#374151")
                .style("font-size", d => d.layer === 2 ? `${smallFontSize}px` : `${baseFontSize}px`);

            // Clean up tooltip on destruction
            window.addEventListener('beforeunload', () => {
                tooltip.remove();
            });
        }

        // Show error message when Sankey diagram fails to load
        function showSankeyError() {
            const sankeyContainer = document.querySelector('.sankey-container');
            sankeyContainer.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444; font-size: 14px; text-align: center;">
                    <div>
                        <div style="margin-bottom: 10px;">⚠️ Sankey diagram unavailable</div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                            D3.js libraries failed to load. This may be due to:<br>
                            • Content Security Policy restrictions<br>
                            • Network connectivity issues<br>
                            • CDN availability problems
                        </div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 15px;">
                            The other charts and waterfall analysis are still fully functional.
                        </div>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            🔄 Retry Page
                        </button>
                    </div>
                </div>
            `;
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
<div style="max-width:1200px;margin:0 auto;padding:0 20px 30px 20px;">
    <p style="text-align:center; color:#64748b; font-size:14px;">
        💡 Have an idea to improve this tool? <a href="https://forms.gle/QzKyMR5wFdhb4Enu5" target="_blank" rel="noopener noreferrer">Share feedback</a>
    </p>
</div>
</body>
</html> 