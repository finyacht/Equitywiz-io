<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RT0B6NXFG6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-RT0B6NXFG6');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waterfall Analysis Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- D3.js with multiple CDN fallbacks -->
    <script>
        function loadD3Script() {
            return new Promise((resolve, reject) => {
                // Try primary CDN first
                const script1 = document.createElement('script');
                script1.src = 'https://d3js.org/d3.v7.min.js';
                script1.onload = () => {
                    console.log('D3.js loaded from d3js.org');
                    resolve();
                };
                script1.onerror = () => {
                    console.log('Trying fallback CDN for D3.js...');
                    // Fallback to jsDelivr
                    const script2 = document.createElement('script');
                    script2.src = 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
                    script2.onload = () => {
                        console.log('D3.js loaded from jsDelivr');
                        resolve();
                    };
                    script2.onerror = () => {
                        console.log('Trying second fallback CDN for D3.js...');
                        // Second fallback to unpkg
                        const script3 = document.createElement('script');
                        script3.src = 'https://unpkg.com/d3@7/dist/d3.min.js';
                        script3.onload = () => {
                            console.log('D3.js loaded from unpkg');
                            resolve();
                        };
                        script3.onerror = () => {
                            console.error('Failed to load D3.js from all CDNs');
                            reject(new Error('D3.js failed to load'));
                        };
                        document.head.appendChild(script3);
                    };
                    document.head.appendChild(script2);
                };
                document.head.appendChild(script1);
            });
        }

        function loadD3SankeyScript() {
            return new Promise((resolve, reject) => {
                // Try primary CDN first
                const script1 = document.createElement('script');
                script1.src = 'https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js';
                script1.onload = () => {
                    console.log('D3-Sankey loaded from unpkg');
                    resolve();
                };
                script1.onerror = () => {
                    console.log('Trying fallback CDN for D3-Sankey...');
                    // Fallback to jsDelivr
                    const script2 = document.createElement('script');
                    script2.src = 'https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js';
                    script2.onload = () => {
                        console.log('D3-Sankey loaded from jsDelivr');
                        resolve();
                    };
                    script2.onerror = () => {
                        console.error('Failed to load D3-Sankey from all CDNs');
                        reject(new Error('D3-Sankey failed to load'));
                    };
                    document.head.appendChild(script2);
                };
                document.head.appendChild(script1);
            });
        }

        // Load scripts sequentially with better error handling
        window.d3LoadPromise = loadD3Script().then(() => {
            return loadD3SankeyScript();
        }).catch(error => {
            console.error('Failed to load D3 libraries:', error);
            // Mark as failed so we can show error immediately
            window.d3LoadFailed = true;
            throw error;
        });

        // Add a timeout fallback
        setTimeout(() => {
            if (typeof d3 === 'undefined' || typeof d3.sankey === 'undefined') {
                console.error('D3 libraries failed to load within timeout');
                window.d3LoadFailed = true;
            }
        }, 10000); // 10 second timeout
    </script>
    <style>
        /* General styles - body styles moved to navbar section */
        
        h1, h2, h3 {
            margin-top: 0;
            color: #111;
        }
        
        h1 { font-size: 1.75rem; margin-bottom: 1rem; }
        h2 { font-size: 1.25rem; margin-bottom: 0.75rem; }
        h3 { font-size: 1rem; margin-bottom: 0.5rem; }
        
        /* Card styles */
        .card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        /* Form elements */
        input, select, button {
            font-size: 14px;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            background-color: white;
        }
        
        input[type="number"] { width: 100px; }
        select { min-width: 150px; background-color: white; }
        
        button {
            background-color: #3b82f6;
            color: white;
            border: none;
            cursor: pointer;
            padding: 8px 16px;
            margin-top: 8px;
        }
        
        button:hover { background-color: #2563eb; }
        
        button.delete {
            background-color: #ef4444;
            padding: 4px 8px;
            font-size: 12px;
        }
        
        button.delete:hover { background-color: #dc2626; }
        
        /* Form layouts */
        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 1rem;
        }
        
        .form-field {
            flex: 1;
            min-width: 200px;
        }
        
        label {
            display: block;
            font-size: 14px;
            margin-bottom: 4px;
            font-weight: 500;
        }
        
        /* Vertical layout */
        .section {
            margin-bottom: 1.5rem;
        }
        
        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            font-size: 14px;
        }
        
        th, td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb;
            white-space: nowrap;
        }
        
        th { font-weight: 600; }
        
        /* Compact table inputs */
        table input, table select {
            width: 100%;
            min-width: 80px;
            padding: 4px 6px;
            font-size: 13px;
        }
        
        /* Specific column widths */
        #shareClassesTable th:nth-child(1), #shareClassesTable td:nth-child(1) { width: 12%; } /* Name */
        #shareClassesTable th:nth-child(2), #shareClassesTable td:nth-child(2) { width: 12%; } /* Type */
        #shareClassesTable th:nth-child(3), #shareClassesTable td:nth-child(3) { width: 10%; } /* Seniority */
        #shareClassesTable th:nth-child(4), #shareClassesTable td:nth-child(4) { width: 12%; } /* Liquidation Pref */
        #shareClassesTable th:nth-child(5), #shareClassesTable td:nth-child(5) { width: 12%; } /* Pref Type */
        #shareClassesTable th:nth-child(6), #shareClassesTable td:nth-child(6) { width: 10%; } /* Cap */
        #shareClassesTable th:nth-child(7), #shareClassesTable td:nth-child(7) { width: 10%; } /* Actions */
        
        #transactionsTable th:nth-child(1), #transactionsTable td:nth-child(1) { width: 15%; } /* Share Class */
        #transactionsTable th:nth-child(2), #transactionsTable td:nth-child(2) { width: 35%; } /* Stakeholder */
        #transactionsTable th:nth-child(3), #transactionsTable td:nth-child(3) { width: 15%; } /* Shares */
        #transactionsTable th:nth-child(4), #transactionsTable td:nth-child(4) { width: 15%; } /* Investment */
        #transactionsTable th:nth-child(5), #transactionsTable td:nth-child(5) { width: 10%; } /* Actions */
        
        /* Responsive adjustments */
        @media (max-width: 1200px) {
            table input, table select {
                min-width: 60px;
                font-size: 12px;
            }
            
            th, td {
                padding: 0.4rem 0.3rem;
            }
        }
        
        @media (max-width: 768px) {
            .overflow-auto {
                max-width: 100vw;
            }
            
            table {
                font-size: 12px;
            }
            
            th, td {
                padding: 0.3rem 0.2rem;
            }
            
            .sankey-container {
                height: 300px;
            }
            
            .chart-container {
                height: 250px;
            }
        }
        
        /* Chart containers */
        .chart-container {
            position: relative;
            height: 300px;
            margin: 1rem 0;
        }

        /* Sankey diagram styles */
        .sankey-container {
            width: 100%;
            height: 400px;
            margin: 1rem 0;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            background: #fafafa;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        .sankey-container svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .sankey-node rect {
            stroke: #000;
            stroke-width: 1;
        }

        .sankey-link {
            fill: none;
            stroke-opacity: 0.6;
        }

        .sankey-link:hover {
            stroke-opacity: 0.8;
        }

        .sankey-text {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 12px;
            font-weight: 500;
        }

        .sankey-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
        }
        
        /* Summary section */
        .summary-info {
            font-size: 14px;
            color: #6b7280;
            margin-top: 0.5rem;
        }
        
        .summary-info ul {
            padding-left: 1.5rem;
            margin-top: 0.25rem;
        }
        
        /* Helper classes */
        .text-right { text-align: right; }
        .space-between {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .overflow-auto { overflow: auto; }
        .font-bold { font-weight: 600; }
        .preferred-only {
            transition: all 0.3s ease;
        }
        .preferred-only.hidden {
            display: none;
        }
        
        /* Add to existing styles */
        .editing-row input, .editing-row select {
            width: 100%;
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .editing-row {
            background-color: #f9fafb;
        }

        .action-buttons {
            display: flex;
            gap: 4px;
        }

        .action-buttons button {
            margin: 0;
            padding: 4px 8px;
            font-size: 12px;
        }

        button.primary {
            background-color: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
        }

        button.primary:hover {
            background-color: #2563eb;
        }

        button.save {
            background-color: #10b981;
        }

        button.save:hover {
            background-color: #059669;
        }

        button.cancel {
            background-color: #ef4444;
        }

        button.cancel:hover {
            background-color: #dc2626;
        }

        /* Toggle buttons */
        .toggle-group {
            display: inline-flex;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            overflow: hidden;
        }
        .toggle-group button {
            border: none;
            background: #fff;
            color: #374151;
            padding: 6px 12px;
            font-size: 13px;
            cursor: pointer;
            border-right: 1px solid #d1d5db;
        }
        .toggle-group button:last-child {
            border-right: none;
        }
        .toggle-group button.active {
            background: #3b82f6;
            color: #fff;
        }

        /* Navigation Bar Styles */
        .nav-bar {
            background-color: #3b82f6;
            color: white;
            padding: 15px 40px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            height: 30px;
            margin: 0;
            border: none;
        }

        .nav-bar a {
            display: flex;
            align-items: center;
            text-decoration: none;
            color: white;
            font-weight: 500;
            gap: 12px;
            font-size: 16px;
            transition: opacity 0.2s ease;
        }

        .nav-bar a:hover {
            opacity: 0.8;
        }

        .nav-bar .nav-title {
            margin-left: auto;
            font-weight: 600;
            color: white;
            font-size: 16px;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .nav-bar {
                padding: 15px 20px;
            }
            
            .nav-bar a {
                font-size: 14px;
                gap: 8px;
            }
            
            .nav-bar .nav-title {
                font-size: 14px;
            }
        }
        /* Adjust body to account for fixed navbar */
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.5;
            margin: 0;
            padding: 95px 20px 20px;
            color: #333;
            background-color: #f5f7fa;
        }

        @media (max-width: 768px) {
            body {
                padding: 95px 15px 20px;
            }
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="nav-bar">
        <a href="home.html">
            <svg width="20" height="20" fill="currentColor" viewBox="0 0 20 20">
                <path d="M10.707 2.293a1 1 0 00-1.414 0l-7 7a1 1 0 001.414 1.414L4 10.414V17a1 1 0 001 1h2a1 1 0 001-1v-2a1 1 0 011-1h2a1 1 0 011 1v2a1 1 0 001 1h2a1 1 0 001-1v-6.586l.293.293a1 1 0 001.414-1.414l-7-7z"/>
            </svg>
            Home
        </a>
        <span class="nav-title">Waterfall Analysis Tool</span>
    </nav>

    <h1>Waterfall Analysis Tool</h1>
    
    <!-- Share Classes Management -->
    <div class="card section">
        <div class="space-between">
            <h2>Share Classes</h2>
            <button id="addShareClassBtn" class="primary">+ Add Share Class</button>
        </div>
        
        <div class="overflow-auto">
            <table id="shareClassesTable">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Type</th>
                        <th>Seniority</th>
                        <th>Liquidation Pref</th>
                        <th>Pref Type</th>
                        <th>Cap</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <!-- Transactions Management -->
    <div class="card section">
        <div class="space-between">
            <h2>Transactions</h2>
            <button id="addTransactionBtn" class="primary">+ Add Transaction</button>
        </div>
        
        <div class="overflow-auto">
            <table id="transactionsTable">
                <thead>
                    <tr>
                        <th>Share Class</th>
                        <th>Stakeholder</th>
                        <th>Shares</th>
                        <th>Investment</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    
    <!-- Waterfall Analysis Results -->
    <div class="card section">
        <div class="space-between">
            <div class="space-between" style="gap: 10px; align-items: center;">
                <h2>Waterfall Results</h2>
                <button id="exportExcelBtn" class="primary">Export to Spreadsheet</button>
            </div>
            <div style="display: flex; flex-direction: column; gap: 6px; align-items: flex-end;">
                <label for="exitAmount" style="margin:0;">Exit Amount ($)</label>
                <input id="exitAmount" class="numeric-input" type="text" inputmode="decimal" value="10000000" style="width: 160px;">
            </div>
        </div>
        
        <!-- Summary Table -->
        <div>
            <div class="space-between" style="align-items: flex-end;">
                <h3>Distribution Summary</h3>
                <div class="toggle-group">
                    <button id="viewShareClass" class="active">By Share Class</button>
                    <button id="viewTransactions">By Share Transaction</button>
                </div>
            </div>
            <div class="overflow-auto">
                <table id="summaryTable">
                    <thead>
                        <tr>
                            <th>Share Class</th>
                            <th>Amount ($)</th>
                            <th>Percentage</th>
                            <th>ROI</th>
                            <th>Price/Share</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        <!-- Combined Distribution Chart -->
        <div>
            <h3>Distribution Breakdown</h3>
            <div class="chart-container">
                <canvas id="combinedChart"></canvas>
            </div>
        </div>
        
        <!-- Sankey Flow Diagram -->
        <div>
            <h3>Distribution Flow Diagram</h3>
            <div class="sankey-container">
                <svg id="sankeyDiagram"></svg>
            </div>
        </div>
        
        <!-- Exit Value Distribution Chart -->
        <div>
            <h3>Exit Value Sensitivity Analysis</h3>
            <div class="chart-container">
                <canvas id="exitDistributionChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // State management
        const DEFAULT_SHARE_CLASSES = [
            { id: 1, name: "Series A", type: "preferred", seniority: 1, liquidationPref: 1, prefType: "participating", cap: null },
            { id: 2, name: "Series B", type: "preferred", seniority: 2, liquidationPref: 1.5, prefType: "participating", cap: 3 },
            { id: 3, name: "Series C", type: "common", seniority: 3, liquidationPref: 1, prefType: "non-participating", cap: null }
        ];
        
        const DEFAULT_TRANSACTIONS = [
            { id: 1, shareClass: "Series A", shares: 1000000, investment: 1000000, stakeholder: "Venture Capital Fund LP" },
            { id: 2, shareClass: "Series B", shares: 2000000, investment: 2000000, stakeholder: "Growth Equity Partners" },
            { id: 3, shareClass: "Series C", shares: 750000, investment: 0, stakeholder: "John Smith (Founder)" },
            { id: 4, shareClass: "Series C", shares: 200000, investment: 0, stakeholder: "Jane Doe (Employee)" },
            { id: 5, shareClass: "Series C", shares: 300000, investment: 0, stakeholder: "Mike Johnson (CTO)" }
        ];

        let shareClasses = [...DEFAULT_SHARE_CLASSES];
        let transactions = [...DEFAULT_TRANSACTIONS];
        let exitAmount = 10000000;
        
        // Default stakeholder options for dropdown
        const DEFAULT_STAKEHOLDERS = [
            "John Smith (Founder)",
            "Jane Doe (Employee)", 
            "Mike Johnson (CTO)",
            "Sarah Wilson (COO)",
            "David Brown (VP Engineering)",
            "Lisa Garcia (Head of Product)",
            "Venture Capital Fund LP",
            "Growth Equity Partners",
            "Strategic Investor Corp",
            "Angel Investor Group",
            "Family Office Investment",
            "Employee Stock Option Pool"
        ];
        
        // Charts
        let summaryChart = null;
        let exitDistributionChart = null;
        let summaryView = 'shareClass'; // 'shareClass' | 'transaction'
        
        // Numeric formatting helpers
        function parseNumber(value) {
            const cleaned = String(value ?? '').replace(/,/g, '').trim();
            const num = parseFloat(cleaned);
            return isNaN(num) ? 0 : num;
        }

        function formatNumberInputElement(input) {
            const cleaned = String(input.value ?? '').replace(/,/g, '').trim();
            if (cleaned === '') {
                input.value = '';
                return;
            }
            const num = parseFloat(cleaned);
            input.value = isNaN(num) ? '' : num.toLocaleString('en-US');
        }

        function attachNumericFormatting(root = document) {
            const inputs = root.querySelectorAll('.numeric-input');
            inputs.forEach(input => {
                if (input.dataset.numericFormatterAttached) return;
                input.dataset.numericFormatterAttached = 'true';

                // Clean non-numeric characters except digits, dot, comma, minus
                input.addEventListener('input', () => {
                    const cleaned = input.value.replace(/[^\d.,-]/g, '');
                    if (cleaned !== input.value) {
                        input.value = cleaned;
                    }
                });

                input.addEventListener('focus', () => {
                    input.value = input.value.replace(/,/g, '');
                    // Defer select to allow focus to settle
                    setTimeout(() => input.select(), 0);
                });

                input.addEventListener('blur', () => formatNumberInputElement(input));

                // Initial formatting pass
                formatNumberInputElement(input);
            });
        }

        // Display helpers
        function formatROI(payout, investment) {
            if (!investment || investment <= 0) return 'N/A';
            const multiple = payout / investment;
            if (!isFinite(multiple)) return 'N/A';
            return `${multiple.toFixed(2)}x`;
        }

        function formatPricePerShare(payout, shares) {
            if (!shares || shares <= 0) return 'N/A';
            const pps = payout / shares;
            return `$${pps.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        }

        // Aggregates for exports and ROI calculations
        function getShareClassAggregates() {
            const aggregates = {};
            transactions.forEach(tx => {
                const cls = tx.shareClass;
                if (!aggregates[cls]) {
                    aggregates[cls] = { investment: 0, shares: 0 };
                }
                aggregates[cls].investment += parseNumber(tx.investment) || 0;
                aggregates[cls].shares += parseNumber(tx.shares) || 0;
            });
            return aggregates;
        }

        // DOM Elements
        const shareClassesTableBody = document.querySelector('#shareClassesTable tbody');
        const transactionsTableBody = document.querySelector('#transactionsTable tbody');
        const summaryTableBody = document.querySelector('#summaryTable tbody');
        const txShareClassSelect = document.querySelector('#txShareClass');
        
        // Make functions globally accessible for onclick handlers
        window.deleteShareClass = function(id) {
            const shareClass = shareClasses.find(sc => sc.id === id);
            shareClasses = shareClasses.filter(sc => sc.id !== id);
            transactions = transactions.filter(tx => tx.shareClass !== shareClass.name);
            
            renderShareClasses();
            renderTransactions();
            updateWaterfallAnalysis();
        };
        
        window.deleteTransaction = function(id) {
            transactions = transactions.filter(tx => tx.id !== id);
            
            renderTransactions();
            updateWaterfallAnalysis();
        };
        
        // Reset to default data
        function resetToDefault() {
            shareClasses = [...DEFAULT_SHARE_CLASSES];
            transactions = [...DEFAULT_TRANSACTIONS];
            exitAmount = 10000000;
            document.getElementById('exitAmount').value = exitAmount;
            
            renderShareClasses();
            renderTransactions();
            attachNumericFormatting();
            formatNumberInputElement(document.getElementById('exitAmount'));
            updateWaterfallAnalysis();
        }

        // Initialize the application
        function init() {
            // Event listeners for add buttons
            document.getElementById('addShareClassBtn').addEventListener('click', addNewShareClassRow);
            document.getElementById('addTransactionBtn').addEventListener('click', addNewTransactionRow);
            document.getElementById('exitAmount').addEventListener('input', updateExitAmount);
            document.getElementById('viewShareClass').addEventListener('click', () => {
                summaryView = 'shareClass';
                document.getElementById('viewShareClass').classList.add('active');
                document.getElementById('viewTransactions').classList.remove('active');
                renderSummaryTable(calculateSummaryWaterfall());
            });
            document.getElementById('viewTransactions').addEventListener('click', () => {
                summaryView = 'transaction';
                document.getElementById('viewTransactions').classList.add('active');
                document.getElementById('viewShareClass').classList.remove('active');
                renderSummaryTable(calculateSummaryWaterfall());
            });
            document.getElementById('exportExcelBtn').addEventListener('click', exportToExcel);
            
            // Add window resize listener for responsive Sankey diagram
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Only redraw if the sankey diagram exists
                    if (document.getElementById('sankeyDiagram').children.length > 0) {
                        updateWaterfallAnalysis();
                    }
                }, 250); // Debounce resize events
            });
            
            // Load default data and wait for D3 if needed
            resetToDefault();
            
            // Ensure D3 is loaded before initial render
            if (window.d3LoadPromise) {
                window.d3LoadPromise.then(() => {
                    console.log('D3 fully loaded, updating waterfall analysis...');
                    // Small delay to ensure DOM is ready
                    setTimeout(updateWaterfallAnalysis, 200);
                }).catch((error) => {
                    console.error('D3 failed to load during init:', error);
                });
            }
        }
        
        // Update exit amount
        function updateExitAmount() {
            exitAmount = parseNumber(document.getElementById('exitAmount').value) || 0;
            updateWaterfallAnalysis();
        }
        
        // Render share classes to the table
        function renderShareClasses() {
            shareClassesTableBody.innerHTML = '';
            
            shareClasses.forEach(sc => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td><input type="text" class="name" value="${sc.name}" onchange="updateShareClass(${sc.id}, this)"></td>
                    <td>
                        <select class="type" onchange="updateShareClass(${sc.id}, this)">
                            <option value="preferred" ${sc.type === 'preferred' ? 'selected' : ''}>Preferred</option>
                            <option value="common" ${sc.type === 'common' ? 'selected' : ''}>Common</option>
                        </select>
                    </td>
                    <td><input type="text" inputmode="decimal" class="seniority numeric-input" min="1" value="${sc.seniority}" onchange="updateShareClass(${sc.id}, this)"></td>
                    <td>
                        <input type="text" inputmode="decimal" class="liquidationPref numeric-input" min="1" step="0.1" value="${sc.liquidationPref}" 
                        onchange="updateShareClass(${sc.id}, this)" 
                        style="display: ${sc.type === 'preferred' ? 'block' : 'none'}">
                    </td>
                    <td>
                        <select class="prefType" onchange="updateShareClass(${sc.id}, this)" 
                        style="display: ${sc.type === 'preferred' ? 'block' : 'none'}">
                            <option value="non-participating" ${sc.prefType === 'non-participating' ? 'selected' : ''}>Non-Part.</option>
                            <option value="participating" ${sc.prefType === 'participating' ? 'selected' : ''}>Part.</option>
                        </select>
                    </td>
                    <td>
                        <input type="text" inputmode="decimal" class="cap numeric-input" min="0" step="0.1" 
                        value="${sc.cap || ''}" placeholder="No cap"
                        onchange="updateShareClass(${sc.id}, this)"
                        style="display: ${sc.type === 'preferred' && sc.prefType === 'participating' ? 'block' : 'none'}">
                    </td>
                    <td><button class="delete" onclick="deleteShareClass(${sc.id})">Delete</button></td>
                `;
                
                // Add type change handler
                const typeSelect = row.querySelector('.type');
                const prefFields = [row.querySelector('.liquidationPref'), row.querySelector('.prefType')];
                const capField = row.querySelector('.cap');
                
                typeSelect.addEventListener('change', function() {
                    const isPreferred = this.value === 'preferred';
                    prefFields.forEach(field => {
                        field.style.display = isPreferred ? 'block' : 'none';
                    });
                    capField.style.display = 
                        (isPreferred && row.querySelector('.prefType').value === 'participating') ? 'block' : 'none';
                });

                // Add preference type change handler
                const prefTypeEl = row.querySelector('.prefType');
                if (prefTypeEl) {
                    prefTypeEl.addEventListener('change', function() {
                        if (typeSelect.value === 'preferred') {
                            capField.style.display = 
                                this.value === 'participating' ? 'block' : 'none';
                        }
                    });
                }
                
                shareClassesTableBody.appendChild(row);
            });

            attachNumericFormatting(shareClassesTableBody);
        }
        
        // Render transactions to the table
        function renderTransactions() {
            transactionsTableBody.innerHTML = '';
            
            transactions.forEach(tx => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>
                        <select class="shareClass" onchange="updateTransaction(${tx.id}, this)">
                            ${shareClasses.map(sc => 
                                `<option value="${sc.name}" ${tx.shareClass === sc.name ? 'selected' : ''}>${sc.name}</option>`
                            ).join('')}
                        </select>
                    </td>
                    <td>
                        <input type="text" class="stakeholder" value="${tx.stakeholder || ''}" 
                        placeholder="Enter stakeholder name" list="stakeholder-options-${tx.id}"
                        onchange="updateTransaction(${tx.id}, this)" oninput="updateTransaction(${tx.id}, this)">
                        <datalist id="stakeholder-options-${tx.id}">
                            ${DEFAULT_STAKEHOLDERS.map(stakeholder => 
                                `<option value="${stakeholder}">`
                            ).join('')}
                        </datalist>
                    </td>
                    <td>
                        <input type="text" inputmode="decimal" class="shares numeric-input" min="0" value="${tx.shares}" 
                        onchange="updateTransaction(${tx.id}, this)">
                    </td>
                    <td>
                        <input type="text" inputmode="decimal" class="investment numeric-input" min="0" value="${tx.investment}" 
                        onchange="updateTransaction(${tx.id}, this)">
                    </td>
                    <td><button class="delete" onclick="deleteTransaction(${tx.id})">Delete</button></td>
                `;
                
                transactionsTableBody.appendChild(row);
            });

            attachNumericFormatting(transactionsTableBody);
        }

        // Update share class
        window.updateShareClass = function(id, element) {
            const shareClass = shareClasses.find(sc => sc.id === id);
            if (!shareClass) return;

            const row = element.closest('tr');
            const type = row.querySelector('.type').value;
            
            shareClass.name = row.querySelector('.name').value.trim();
            shareClass.type = type;
            shareClass.seniority = parseNumber(row.querySelector('.seniority').value) || 1;
            
            if (type === 'preferred') {
                shareClass.liquidationPref = parseNumber(row.querySelector('.liquidationPref').value) || 1;
                shareClass.prefType = row.querySelector('.prefType').value;
                const capInput = row.querySelector('.cap').value;
                shareClass.cap = capInput !== '' ? parseNumber(capInput) : null;
            } else {
                shareClass.liquidationPref = 1;
                shareClass.prefType = 'non-participating';
                shareClass.cap = null;
            }

            // Update any transactions that reference this share class
            const oldName = shareClass.name;
            transactions.forEach(tx => {
                if (tx.shareClass === oldName) {
                    tx.shareClass = shareClass.name;
                }
            });

            renderShareClasses();
            renderTransactions();
            updateWaterfallAnalysis();
        };

        // Update transaction
        window.updateTransaction = function(id, element) {
            const transaction = transactions.find(tx => tx.id === id);
            if (!transaction) return;

            const row = element.closest('tr');
            
            transaction.shareClass = row.querySelector('.shareClass').value;
            transaction.stakeholder = row.querySelector('.stakeholder').value.trim();
            transaction.shares = parseNumber(row.querySelector('.shares').value) || 0;
            transaction.investment = parseNumber(row.querySelector('.investment').value) || 0;

            // Only update charts if it's not just a typing event
            if (element.className !== 'stakeholder' || element.type !== 'text') {
                updateWaterfallAnalysis();
            }
        };
        
        // Calculate the detailed waterfall analysis
        function calculateDetailedWaterfall() {
            let results = [];
            let remainingProceeds = exitAmount;
            
            // Start with total proceeds
            results.push({
                name: "Total Exit Proceeds",
                value: exitAmount,
                remainingProceeds: remainingProceeds,
                isStarting: true
            });
            
            if (transactions.length === 0) return results;
            
            // Get active share classes with transactions
            const activeShareClasses = shareClasses.filter(sc => 
                transactions.some(tx => tx.shareClass === sc.name)
            );
            
            // Calculate share counts per class (use counts instead of percentages to avoid rounding drift)
            const sharesByClass = {};
            transactions.forEach(tx => {
                const shares = parseFloat(tx.shares) || 0;
                if (!sharesByClass[tx.shareClass]) {
                    sharesByClass[tx.shareClass] = 0;
                }
                sharesByClass[tx.shareClass] += shares;
            });

            const totalShares = Object.values(sharesByClass).reduce((sum, val) => sum + val, 0);
            if (totalShares <= 0) {
                return results; // No shares to distribute against
            }

            // First Round - Liquidation Preferences (only for preferred shares, in order of seniority)
            const preferredClasses = [...activeShareClasses]
                .filter(sc => sc.type === 'preferred')
                .sort((a, b) => {
                    const aRank = Number(a.seniority) || Number.MAX_SAFE_INTEGER;
                    const bRank = Number(b.seniority) || Number.MAX_SAFE_INTEGER;
                    return aRank - bRank; // 1 = most senior, larger numbers = less senior
                });

            // Handle preferred shares liquidation preferences first
            for (const sc of preferredClasses) {
                if (remainingProceeds <= 0) break;
                
                const transactionsForClass = transactions.filter(tx => tx.shareClass === sc.name);
                let totalInvestment = transactionsForClass.reduce((sum, tx) => sum + parseFloat(tx.investment || 0), 0);
                
                // Calculate liquidation preference
                let liquidationPrefAmount = totalInvestment * parseFloat(sc.liquidationPref || 1);
                let prefPayout = Math.min(liquidationPrefAmount, remainingProceeds);
                
                if (prefPayout > 0) {
                    results.push({ 
                        name: `${sc.name} (Liquidation Preference)`, 
                        value: -prefPayout,
                        description: `${sc.name} receives liquidation preference of $${prefPayout.toLocaleString()}`,
                        remainingProceeds,
                        shareClass: sc.name
                    });
                    
                    remainingProceeds -= prefPayout;
                }
            }

            // Second Round - Pro-rata distribution among participating preferred and common
            if (remainingProceeds > 0) {
                // Get participating preferred and common classes
                const participatingClasses = [
                    ...preferredClasses.filter(sc => sc.prefType === "participating"),
                    ...activeShareClasses.filter(sc => sc.type === "common")
                ];

                // Calculate total participating shares
                const participatingTotal = participatingClasses.reduce((sum, sc) => 
                    sum + (sharesByClass[sc.name] || 0), 0
                );

                if (participatingTotal > 0) {
                    const participationPool = remainingProceeds;
                    let distributed = 0;
                    const plannedDistributions = [];
                    
                    for (const sc of participatingClasses) {
                        const proRataShare = (sharesByClass[sc.name] || 0) / participatingTotal;
                        let participationAmount = proRataShare * participationPool;

                        // Apply caps for participating preferred if they exist
                        if (sc.type === 'preferred' && sc.cap) {
                            const transactionsForClass = transactions.filter(tx => tx.shareClass === sc.name);
                            const totalInvestment = transactionsForClass.reduce((sum, tx) => sum + parseFloat(tx.investment || 0), 0);
                            const currentPayout = results
                                .filter(r => r.shareClass === sc.name)
                                .reduce((sum, r) => sum - r.value, 0);
                            
                            const capAmount = totalInvestment * sc.cap;
                            participationAmount = Math.min(participationAmount, Math.max(0, capAmount - currentPayout));
                        }

                        if (participationAmount > 0.01) {
                            const distributionType = sc.type === 'common' ? 'Common Distribution' : 'Participation';
                            plannedDistributions.push({
                                name: `${sc.name} (${distributionType})`,
                                amount: participationAmount,
                                description: `${sc.name} receives ${distributionType.toLowerCase()} of $${participationAmount.toLocaleString()}`,
                                shareClass: sc.name
                            });
                            distributed += participationAmount;
                        }
                    }

                    plannedDistributions.forEach(dist => {
                        results.push({
                            name: dist.name,
                            value: -dist.amount,
                            description: dist.description,
                            remainingProceeds,
                            shareClass: dist.shareClass
                        });
                    });

                    remainingProceeds -= distributed;
                }
            }

            // If there are still remaining proceeds, distribute them pro-rata among all participating classes
            // (including those that may have hit caps - distribute the remainder)
            if (remainingProceeds > 0.01) { // Using small threshold to avoid floating point issues
                // Get all participating classes (participating preferred + common)
                const allParticipatingClasses = [
                    ...preferredClasses.filter(sc => sc.prefType === "participating"),
                    ...activeShareClasses.filter(sc => sc.type === "common")
                ];

                // Calculate total participating ownership
                const totalParticipatingOwnership = allParticipatingClasses.reduce((sum, sc) => 
                    sum + (sharesByClass[sc.name] || 0), 0
                );

                if (totalParticipatingOwnership > 0) {
                    const additionalPool = remainingProceeds;
                    let additionalDistributed = 0;
                    const plannedAdditional = [];

                    // Distribute remaining proceeds pro-rata
                    for (const sc of allParticipatingClasses) {
                        const proRataShare = (sharesByClass[sc.name] || 0) / totalParticipatingOwnership;
                        let additionalAmount = proRataShare * additionalPool;

                        // Check if this class has a cap and adjust if necessary
                        if (sc.type === 'preferred' && sc.cap) {
                            const transactionsForClass = transactions.filter(tx => tx.shareClass === sc.name);
                            const totalInvestment = transactionsForClass.reduce((sum, tx) => sum + parseFloat(tx.investment || 0), 0);
                            const currentPayout = results
                                .filter(r => r.shareClass === sc.name)
                                .reduce((sum, r) => sum - r.value, 0);
                            
                            const capAmount = totalInvestment * sc.cap;
                            const availableCapSpace = capAmount - currentPayout;
                            additionalAmount = Math.min(additionalAmount, Math.max(0, availableCapSpace));
                        }

                        if (additionalAmount > 0.01) { // Only add if meaningful amount
                            const distributionType = sc.type === 'common' ? 'Additional Common' : 'Additional Participation';
                            plannedAdditional.push({
                                name: `${sc.name} (${distributionType})`,
                                amount: additionalAmount,
                                description: `${sc.name} receives additional distribution of $${additionalAmount.toLocaleString()}`,
                                shareClass: sc.name
                            });
                            additionalDistributed += additionalAmount;
                        }
                    }

                    plannedAdditional.forEach(dist => {
                        results.push({
                            name: dist.name,
                            value: -dist.amount,
                            description: dist.description,
                            remainingProceeds,
                            shareClass: dist.shareClass
                        });
                    });

                    remainingProceeds -= additionalDistributed;
                }
            }
            
            // Final check: if there are still remaining proceeds due to caps, distribute to common shares only
            if (remainingProceeds > 0.01) {
                const commonClasses = activeShareClasses.filter(sc => sc.type === "common");
                const totalCommonOwnership = commonClasses.reduce((sum, sc) => 
                    sum + (sharesByClass[sc.name] || 0), 0
                );

                if (totalCommonOwnership > 0) {
                    const finalPool = remainingProceeds;
                    let finalDistributed = 0;

                    for (const sc of commonClasses) {
                        const proRataShare = (sharesByClass[sc.name] || 0) / totalCommonOwnership;
                        const finalAmount = proRataShare * finalPool;

                        if (finalAmount > 0.01) {
                            results.push({ 
                                name: `${sc.name} (Final Distribution)`, 
                                value: -finalAmount,
                                description: `${sc.name} receives final distribution of $${finalAmount.toLocaleString()}`,
                                remainingProceeds,
                                shareClass: sc.name
                            });
                            
                            finalDistributed += finalAmount;
                        }
                    }

                    remainingProceeds -= finalDistributed;
                }
            }
            
            return results;
        }
        
        // Calculate summary waterfall distribution
        function calculateSummaryWaterfall() {
            const detailedResults = calculateDetailedWaterfall();
            const summaryByClass = {};
            
            // Skip the first "Total Exit Proceeds" entry
            detailedResults.slice(1).forEach(result => {
                if (!result.shareClass) return;
                
                if (!summaryByClass[result.shareClass]) {
                    summaryByClass[result.shareClass] = {
                        name: result.shareClass,
                        payout: 0,
                        components: {
                            'Liquidation Preference': 0,
                            'Participation': 0,
                            'Common Distribution': 0
                        }
                    };
                }
                
                const amount = Math.abs(result.value);
                summaryByClass[result.shareClass].payout += amount;
                
                // Categorize the payment
                if (result.name.includes('Liquidation Preference')) {
                    summaryByClass[result.shareClass].components['Liquidation Preference'] += amount;
                } else if (result.name.includes('Participation') || result.name.includes('Additional Participation')) {
                    summaryByClass[result.shareClass].components['Participation'] += amount;
                } else if (result.name.includes('Common') || result.name.includes('Final Distribution')) {
                    summaryByClass[result.shareClass].components['Common Distribution'] += amount;
                }
            });
            
            return Object.values(summaryByClass).map(summary => ({
                ...summary,
                percentage: Math.round((summary.payout / exitAmount) * 10000) / 100
            }));
        }

        // Calculate summary per transaction using share-class payouts as base
        function calculateTransactionSummary(summaryData) {
            const sharesByClass = {};
            const investmentByClass = {};
            transactions.forEach(tx => {
                sharesByClass[tx.shareClass] = (sharesByClass[tx.shareClass] || 0) + (parseNumber(tx.shares) || 0);
                investmentByClass[tx.shareClass] = (investmentByClass[tx.shareClass] || 0) + (parseNumber(tx.investment) || 0);
            });

            const transactionSummaries = [];
            transactions.forEach(tx => {
                const classSummary = summaryData.find(s => s.name === tx.shareClass);
                if (!classSummary || classSummary.payout <= 0) return;
                const totalClassShares = sharesByClass[tx.shareClass] || 0;
                const txShares = parseNumber(tx.shares) || 0;
                const txInvestment = parseNumber(tx.investment) || 0;

                const payout = totalClassShares > 0 ? (txShares / totalClassShares) * classSummary.payout : 0;
                const percentage = exitAmount > 0 ? Math.round((payout / exitAmount) * 10000) / 100 : 0;

                // Distribute components proportionally for richer detail (not displayed but available)
                const components = {};
                Object.keys(classSummary.components || {}).forEach(key => {
                    const classComponent = classSummary.components[key] || 0;
                    components[key] = totalClassShares > 0 ? (txShares / totalClassShares) * classComponent : 0;
                });

                transactionSummaries.push({
                    id: tx.id,
                    name: tx.stakeholder ? `${tx.stakeholder}` : 'Unnamed Stakeholder',
                    shareClass: tx.shareClass,
                    shares: txShares,
                    investment: txInvestment,
                    payout,
                    percentage,
                    components
                });
            });

            return transactionSummaries;
        }

        // Export current view to XLSX
        function exportToExcel() {
            if (typeof XLSX === 'undefined') {
                alert('Export library not loaded. Please try again.');
                return;
            }

            const summaryData = calculateSummaryWaterfall();
            const txSummary = calculateTransactionSummary(summaryData);
            const aggregates = getShareClassAggregates();
            const waterfallSteps = calculateDetailedWaterfall();
            const totalSharesAll = Object.values(aggregates).reduce((sum, v) => sum + ((v && v.shares) || 0), 0);

            const wb = XLSX.utils.book_new();

            // Cap Table sheet (first sheet) with metadata columns
            const capSheet = [];
            const totalInvestmentAll = Object.values(aggregates).reduce((s, v) => s + ((v && v.investment) || 0), 0);

            // Header for share classes with extra columns
            capSheet.push(['Cap Table - Share Classes']);
            capSheet.push(['Name', '% Ownership', 'Investment ($)', 'Type', 'Seniority', 'Liquidation Pref', 'Pref Type', 'Cap']);

            const capClassStartRow = capSheet.length + 1; // header row number for formulas
            const capClassRowMap = {};
            summaryData.forEach((item, idx) => {
                const excelRow = capClassStartRow + idx;
                const agg = aggregates[item.name] || { investment: 0, shares: 0 };
                const scMeta = shareClasses.find(sc => sc.name === item.name) || {};
                capClassRowMap[item.name] = excelRow;
                capSheet.push([
                    item.name,
                    { t: 'n', f: totalSharesAll > 0 ? `${agg.shares}/${totalSharesAll}` : '0' },
                    { t: 'n', v: agg.investment },
                    scMeta.type || '',
                    scMeta.seniority || '',
                    scMeta.liquidationPref || '',
                    scMeta.prefType || '',
                    scMeta.cap != null ? scMeta.cap : ''
                ]);
            });

            // Totals row for classes
            capSheet.push([
                'Total',
                { t: 'n', v: 1 },
                { t: 'n', v: totalInvestmentAll },
                '',
                '',
                '',
                '',
                ''
            ]);

            // Blank line
            capSheet.push([]);

            // Header for transactions
            capSheet.push(['Cap Table - Share Transactions']);
            capSheet.push(['Name', '% Ownership', 'Investment ($)']);
            const capTxStartRow = capSheet.length + 1;

            transactions.forEach((tx, idx) => {
                const excelRow = capTxStartRow + idx;
                const shares = parseNumber(tx.shares) || 0;
                capSheet.push([
                    tx.stakeholder || `Tx ${tx.id}`,
                    { t: 'n', f: totalSharesAll > 0 ? `${shares}/${totalSharesAll}` : '0' },
                    { t: 'n', v: parseNumber(tx.investment) || 0 }
                ]);
            });

            // Totals row for transactions
            const txInvestTotal = transactions.reduce((s, tx) => s + (parseNumber(tx.investment) || 0), 0);
            capSheet.push([
                'Total',
                { t: 'n', v: 1 },
                { t: 'n', v: txInvestTotal }
            ]);

            const capWS = XLSX.utils.aoa_to_sheet(capSheet);
            XLSX.utils.book_append_sheet(wb, capWS, 'Cap Table');

            // Share Class sheet (simplified)
            const scSheet = [
                ['Share Class', 'Amount ($)', 'Distribution % (LP adj.)', 'ROI', 'Price/Share', 'Investment ($)', 'Shares']
            ];

            summaryData.forEach((item, idx) => {
                const rowIndex = idx + 2; // header is row 1
                const agg = aggregates[item.name] || { investment: 0, shares: 0 };
                scSheet.push([
                    item.name,
                    { t: 'n', v: item.payout },
                    { t: 'n', v: item.percentage }, // distribution share already reflects prefs/caps from FE logic
                    { t: 'n', f: `B${rowIndex}/F${rowIndex}` },
                    { t: 'n', f: `B${rowIndex}/G${rowIndex}` },
                    { t: 'n', v: agg.investment },
                    { t: 'n', v: agg.shares }
                ]);
            });

            const totalRowIndex = scSheet.length + 1;
            const totalInvestment = Object.values(aggregates).reduce((s, v) => s + ((v && v.investment) || 0), 0);

            // Totals row with share & investment sums
            scSheet.push([
                'Total',
                { t: 'n', v: exitAmount },
                { t: 'n', v: 100 },
                '',
                '',
                { t: 'n', v: totalInvestment },
                { t: 'n', v: totalSharesAll }
            ]);

            const scWS = XLSX.utils.aoa_to_sheet(scSheet);
            XLSX.utils.book_append_sheet(wb, scWS, 'By Share Class');

            // Transaction sheet (simplified)
            const txSheet = [
                ['Stakeholder / Transaction', 'Share Class', 'Amount ($)', 'Distribution % (LP adj.)', 'ROI', 'Price/Share', 'Investment ($)', 'Shares']
            ];

            txSummary.forEach((item, idx) => {
                const rowIndex = idx + 2;
                txSheet.push([
                    item.name,
                    item.shareClass,
                    { t: 'n', v: item.payout },
                    { t: 'n', v: item.percentage },
                    { t: 'n', f: `C${rowIndex}/G${rowIndex}` },
                    { t: 'n', f: `C${rowIndex}/H${rowIndex}` },
                    { t: 'n', v: item.investment },
                    { t: 'n', v: item.shares }
                ]);
            });

            txSheet.push([
                'Total',
                '',
                { t: 'n', v: exitAmount },
                { t: 'n', v: 100 },
                '',
                '',
                '',
                '',
                ''
            ]);

            const txWS = XLSX.utils.aoa_to_sheet(txSheet);
            XLSX.utils.book_append_sheet(wb, txWS, 'By Transaction');

            // Waterfall steps sheet (sequential; column D shows LP multiple or participation % from Cap Table)
            const stepsSheet = [
                ['Step', 'Share Class', 'Amount ($)', 'LP / Participation Factor', 'Remaining Proceeds ($)', 'Description']
            ];

            // Row 2: starting proceeds
            stepsSheet.push([
                'Total Exit Proceeds',
                '',
                { t: 'n', v: exitAmount },
                '',
                { t: 'n', v: exitAmount },
                'Starting total proceeds'
            ]);

            let lastLpRemainingRow = null;

            waterfallSteps.slice(1).forEach(step => {
                const nextRowIndex = stepsSheet.length + 1; // +1 because header row counts
                const prevRowIndex = nextRowIndex - 1;
                const scName = step.shareClass || '';
                const capRow = capClassRowMap[scName];

                // Default to prior-remaining based factor if cap row missing
                let factorFormula = `IF(E${prevRowIndex}=0,0,C${nextRowIndex}/E${prevRowIndex})`;
                let amountFormula = `E${prevRowIndex}*D${nextRowIndex}`;

                if (capRow) {
                    const ownershipRef = `'Cap Table'!$B${capRow}`;
                    const lpRef = `'Cap Table'!$F${capRow}`;
                    const investmentRef = `'Cap Table'!$C${capRow}`;

                    const isLiquidationPref = (step.name || '').indexOf('Liquidation Preference') !== -1;
                    if (isLiquidationPref) {
                        factorFormula = lpRef; // LP multiple
                        amountFormula = `${investmentRef}*${lpRef}`;
                        lastLpRemainingRow = nextRowIndex; // remaining after this row captured below
                    } else {
                        // participation/common distribution uses ownership %
                        const baseRemainingRef = lastLpRemainingRow ? `E${lastLpRemainingRow}` : `E${prevRowIndex}`;
                        factorFormula = ownershipRef;
                        amountFormula = `${baseRemainingRef}*${ownershipRef}`;
                    }
                }

                stepsSheet.push([
                    step.name || '',
                    scName,
                    { t: 'n', f: amountFormula },
                    { t: 'n', f: factorFormula },
                    { t: 'n', f: `E${prevRowIndex}-C${nextRowIndex}` },
                    step.description || ''
                ]);
            });

            const stepsWS = XLSX.utils.aoa_to_sheet(stepsSheet);
            XLSX.utils.book_append_sheet(wb, stepsWS, 'Waterfall Steps');

            XLSX.writeFile(wb, 'waterfall_export.xlsx');
        }
        
        // Update the waterfall analysis charts and tables
        function updateWaterfallAnalysis() {
            const waterfallSteps = calculateDetailedWaterfall();
            const summaryData = calculateSummaryWaterfall();
            
            // Update the summary table
            renderSummaryTable(summaryData);
            
            // Update the charts
            renderCombinedChart(waterfallSteps, summaryData);
            renderExitDistributionChart();
            renderSankeyDiagram(waterfallSteps, summaryData);
        }
        
        // Calculate distribution for a specific exit value
        function calculateDistributionAtExit(exitValue) {
            const originalExitAmount = exitAmount;
            exitAmount = exitValue;
            const distribution = calculateSummaryWaterfall();
            exitAmount = originalExitAmount;
            return distribution;
        }
        
        // Render summary table
        function renderSummaryTable(summaryData) {
            // Clear the table
            summaryTableBody.innerHTML = '';

            if (summaryView === 'shareClass') {
                // Headers for share class view
                summaryTableBody.parentElement.querySelector('thead').innerHTML = `
                    <tr>
                        <th>Share Class</th>
                        <th>Amount ($)</th>
                        <th>Percentage</th>
                        <th>ROI</th>
                        <th>Price/Share</th>
                    </tr>
                `;

                // Add each summary row
                summaryData.forEach(result => {
                    // Compute totals for ROI and price/share
                    const classTransactions = transactions.filter(tx => tx.shareClass === result.name);
                    const totalInvestment = classTransactions.reduce((sum, tx) => sum + (parseNumber(tx.investment) || 0), 0);
                    const totalShares = classTransactions.reduce((sum, tx) => sum + (parseNumber(tx.shares) || 0), 0);

                    const row = document.createElement('tr');
                    
                    row.innerHTML = `
                        <td>${result.name}</td>
                        <td>$${result.payout.toLocaleString()}</td>
                        <td>${result.percentage}%</td>
                        <td>${formatROI(result.payout, totalInvestment)}</td>
                        <td>${formatPricePerShare(result.payout, totalShares)}</td>
                    `;
                    
                    summaryTableBody.appendChild(row);
                });
                
                // Add total row
                const totalRow = document.createElement('tr');
                totalRow.className = 'font-bold';
                
                totalRow.innerHTML = `
                    <td>Total</td>
                    <td>$${exitAmount.toLocaleString()}</td>
                    <td>100%</td>
                    <td>N/A</td>
                    <td>N/A</td>
                `;
                
                summaryTableBody.appendChild(totalRow);
            } else {
                // Transaction view
                const txSummary = calculateTransactionSummary(summaryData);

                summaryTableBody.parentElement.querySelector('thead').innerHTML = `
                    <tr>
                        <th>Stakeholder / Transaction</th>
                        <th>Share Class</th>
                        <th>Amount ($)</th>
                        <th>Percentage</th>
                        <th>ROI</th>
                        <th>Price/Share</th>
                    </tr>
                `;

                txSummary.forEach(result => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${result.name}</td>
                        <td>${result.shareClass}</td>
                        <td>$${result.payout.toLocaleString()}</td>
                        <td>${result.percentage}%</td>
                        <td>${formatROI(result.payout, result.investment)}</td>
                        <td>${formatPricePerShare(result.payout, result.shares)}</td>
                    `;
                    summaryTableBody.appendChild(row);
                });

                // Totals row
                const totalRow = document.createElement('tr');
                totalRow.className = 'font-bold';
                totalRow.innerHTML = `
                    <td>Total</td>
                    <td>-</td>
                    <td>$${exitAmount.toLocaleString()}</td>
                    <td>100%</td>
                    <td>N/A</td>
                    <td>N/A</td>
                `;
                summaryTableBody.appendChild(totalRow);
            }
        }
        
        // Render combined chart
        function renderCombinedChart(waterfallSteps, summaryData) {
            const ctx = document.getElementById('combinedChart').getContext('2d');
            
            if (summaryChart) {
                summaryChart.destroy();
            }

            // Group steps by share class and distribution type
            const shareClassSteps = {};
            waterfallSteps.forEach(step => {
                if (step.shareClass && !step.isStarting && !step.isFinal) {
                    if (!shareClassSteps[step.shareClass]) {
                        shareClassSteps[step.shareClass] = {
                            'Liquidation Preference': 0,
                            'Participation': 0,
                            'Common Distribution': 0
                        };
                    }
                    const match = step.name.match(/\((.*?)\)/);
                    if (match) {
                        const type = match[1];
                        if (type === "Liquidation Preference") {
                            shareClassSteps[step.shareClass]["Liquidation Preference"] += Math.abs(step.value);
                        } else if (type.includes("Participation") || type === "Additional Participation") {
                            shareClassSteps[step.shareClass]["Participation"] += Math.abs(step.value);
                        } else if (type.includes("Common") || type === "Final Distribution") {
                            shareClassSteps[step.shareClass]["Common Distribution"] += Math.abs(step.value);
                        }
                    }
                }
            });

            // Create datasets for each distribution type
            const distributionTypes = [
                'Liquidation Preference',
                'Participation',
                'Common Distribution'
            ];
            const datasets = distributionTypes.map(type => ({
                label: type,
                data: summaryData.map(summary => {
                    return (shareClassSteps[summary.name] && shareClassSteps[summary.name][type]) ? shareClassSteps[summary.name][type] : 0;
                }),
                backgroundColor: getDistributionTypeColor(type),
                borderColor: getDistributionTypeColor(type, 0.8),
                borderWidth: 1
            })).filter(dataset => dataset.data.some(value => value > 0)); // Only include datasets with non-zero values

            summaryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: summaryData.map(d => d.name),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const shareClass = context[0].label;
                                    const sc = shareClasses.find(s => s.name === shareClass);
                                    if (!sc) return shareClass;
                                    
                                    let title = shareClass;
                                    if (sc.type === 'preferred') {
                                        title += ` (${sc.prefType})`;
                                        if (sc.prefType === 'participating' && sc.cap) {
                                            title += ` - ${sc.cap}x cap`;
                                        }
                                    }
                                    return title;
                                },
                                label: function(context) {
                                    const value = context.raw;
                                    if (value === 0) return null;
                                    const percentage = ((value / exitAmount) * 100).toFixed(1);
                                    return `${context.dataset.label}: $${value.toLocaleString()} (${percentage}%)`;
                                },
                                afterBody: function(context) {
                                    const shareClass = context[0].label;
                                    const total = datasets.reduce((sum, dataset) => 
                                        sum + (dataset.data[context[0].dataIndex] || 0), 0
                                    );
                                    const percentage = ((total/exitAmount)*100).toFixed(1);
                                    return [`Total Payout: $${total.toLocaleString()} (${percentage}%)`];
                                }
                            }
                        },
                        legend: {
                            position: 'bottom',
                            labels: {
                                boxWidth: 12,
                                padding: 15
                            }
                        }
                    }
                }
            });
        }
        
        // Helper function to get colors for distribution types
        function getDistributionTypeColor(type, alpha = 1) {
            // Use consistent colors for each distribution type
            const colors = {
                'Liquidation Preference': `rgba(59, 130, 246, ${alpha})`, // Blue for liquidation preferences
                'Participation': `rgba(16, 185, 129, ${alpha})`, // Green for participation
                'Common Distribution': `rgba(107, 114, 128, ${alpha})` // Gray for common
            };
            return colors[type] || `rgba(107, 114, 128, ${alpha})`;
        }
        
        // Render exit distribution chart
        function renderExitDistributionChart() {
            const ctx = document.getElementById('exitDistributionChart').getContext('2d');
            
            if (exitDistributionChart) {
                exitDistributionChart.destroy();
            }
            
            // Generate exit values from 0 to 2x current exit amount
            const maxExit = exitAmount * 2;
            const numPoints = 20;
            const exitValues = Array.from({length: numPoints + 1}, (_, i) => (maxExit * i) / numPoints);
            
            // Get all unique share classes
            const activeShareClasses = [...new Set(
                shareClasses
                    .filter(sc => transactions.some(tx => tx.shareClass === sc.name))
                    .map(sc => sc.name)
            )];
            
            // Calculate distributions for each exit value
            const distributions = exitValues.map(exitValue => {
                const dist = calculateDistributionAtExit(exitValue);
                return activeShareClasses.map(className => {
                    const shareData = dist.find(d => d.name === className);
                    return shareData ? shareData.payout : 0;
                });
            });
            
            // Create datasets for each share class
            const datasets = activeShareClasses.map((className, index) => ({
                label: className,
                data: distributions.map(dist => dist[index]),
                fill: true,
                borderColor: getShareClassColor(className, index),
                backgroundColor: getShareClassColor(className, index, 0.1),
                tension: 0.4
            }));
            
            let verticalLineX = null;
            
            exitDistributionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: exitValues.map(value => formatCurrency(value)),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Exit Value'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Distribution Amount'
                            },
                            ticks: {
                                callback: value => formatCurrency(value)
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(tooltipItems) {
                                    return `Exit Value: ${tooltipItems[0].label}`;
                                },
                                label: function(tooltipItem) {
                                    const exitValue = parseFloat(tooltipItem.raw);
                                    const shareClass = tooltipItem.dataset.label;
                                    const distribution = calculateDistributionAtExit(exitValue);
                                    const shareData = distribution.find(d => d.name === shareClass);
                                    
                                    if (!shareData) {
                                        return `${shareClass}: ${formatCurrency(tooltipItem.raw)}`;
                                    }
                                    
                                    const components = shareData.components;
                                    const totalPercentage = ((shareData.payout / exitValue) * 100).toFixed(1);
                                    
                                    let lines = [`${shareClass}: ${formatCurrency(shareData.payout)} (${totalPercentage}%)`];
                                    
                                    if (components['Liquidation Preference'] > 0) {
                                        const prefPercentage = ((components['Liquidation Preference'] / exitValue) * 100).toFixed(1);
                                        lines.push(`   Liquidation Preference: ${formatCurrency(components['Liquidation Preference'])} (${prefPercentage}%)`);
                                    }
                                    
                                    if (components['Participation'] > 0) {
                                        const partPercentage = ((components['Participation'] / exitValue) * 100).toFixed(1);
                                        lines.push(`   Participation: ${formatCurrency(components['Participation'])} (${partPercentage}%)`);
                                    }
                                    
                                    if (components['Common Distribution'] > 0) {
                                        const commonPercentage = ((components['Common Distribution'] / exitValue) * 100).toFixed(1);
                                        lines.push(`   Common Distribution: ${formatCurrency(components['Common Distribution'])} (${commonPercentage}%)`);
                                    }
                                    
                                    return lines;
                                }
                            }
                        }
                    }
                }
            });
            
            // Add mousemove event listener to draw vertical line
            ctx.canvas.addEventListener('mousemove', (event) => {
                const rect = ctx.canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                verticalLineX = x;
                
                // Clear the canvas and redraw
                exitDistributionChart.draw();
                
                // Draw vertical line
                if (x >= 0 && x <= ctx.canvas.width) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, ctx.canvas.height);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.8)';
                    ctx.stroke();
                    ctx.restore();
                }
            });
            
            // Add mouseleave event listener to clear vertical line
            ctx.canvas.addEventListener('mouseleave', () => {
                verticalLineX = null;
                exitDistributionChart.draw();
            });
            
            // Override the chart's draw function to maintain the vertical line
            const originalDraw = exitDistributionChart.draw;
            exitDistributionChart.draw = function() {
                originalDraw.apply(this, arguments);
                if (verticalLineX !== null) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(verticalLineX, 0);
                    ctx.lineTo(verticalLineX, ctx.canvas.height);
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = 'rgba(102, 102, 102, 0.8)';
                    ctx.stroke();
                    ctx.restore();
                }
            };
        }
        
        // Helper function to format currency
        function formatCurrency(value) {
            return '$' + value.toLocaleString();
        }
        
        // Helper function to get consistent colors for share classes
        function getShareClassColor(className, index, alpha = 1) {
            const colors = {
                'Common': `rgba(168, 85, 247, ${alpha})`, // Purple
                'Series A': `rgba(59, 130, 246, ${alpha})`, // Blue
                'Series B': `rgba(16, 185, 129, ${alpha})`, // Green
                'Series C': `rgba(245, 158, 11, ${alpha})`, // Orange
                'Series D': `rgba(239, 68, 68, ${alpha})`, // Red
            };
            
            return colors[className] || `hsla(${index * 137.5}, 70%, 50%, ${alpha})`;
        }
        
        // Add new share class row
        function addNewShareClassRow() {
            const row = document.createElement('tr');
            row.className = 'editing-row';
            
            row.innerHTML = `
                <td><input type="text" class="name" placeholder="Series A"></td>
                <td>
                    <select class="type">
                        <option value="preferred">Preferred</option>
                        <option value="common">Common</option>
                    </select>
                </td>
                <td><input type="text" inputmode="decimal" class="seniority numeric-input" min="1" value="1"></td>
                <td><input type="text" inputmode="decimal" class="liquidationPref numeric-input" min="1" step="0.1" value="1"></td>
                <td>
                    <select class="prefType">
                        <option value="non-participating">Non-Participating</option>
                        <option value="participating">Participating</option>
                    </select>
                </td>
                <td><input type="text" inputmode="decimal" class="cap numeric-input" min="0" step="0.1" placeholder="No cap"></td>
                <td class="action-buttons">
                    <button class="save" onclick="saveShareClass(this)">Save</button>
                    <button class="cancel" onclick="cancelShareClass(this)">Cancel</button>
                </td>
            `;

            // Add type change handler
            const typeSelect = row.querySelector('.type');
            const prefFields = [row.querySelector('.liquidationPref'), row.querySelector('.prefType')];
            const capField = row.querySelector('.cap');
            
            typeSelect.addEventListener('change', function() {
                const isPreferred = this.value === 'preferred';
                prefFields.forEach(field => {
                    field.parentElement.style.display = isPreferred ? '' : 'none';
                });
                capField.parentElement.style.display = 
                    (isPreferred && row.querySelector('.prefType').value === 'participating') ? '' : 'none';
            });

            // Add preference type change handler
            row.querySelector('.prefType').addEventListener('change', function() {
                if (typeSelect.value === 'preferred') {
                    capField.parentElement.style.display = 
                        this.value === 'participating' ? '' : 'none';
                }
            });
            
            shareClassesTableBody.appendChild(row);
            attachNumericFormatting(row);
        }

        // Save share class
        function saveShareClass(button) {
            const row = button.closest('tr');
            const name = row.querySelector('.name').value.trim();
            if (name === '') return;

            const type = row.querySelector('.type').value;
            const seniority = parseNumber(row.querySelector('.seniority').value) || 1;
            const liquidationPref = type === 'preferred' ? (parseNumber(row.querySelector('.liquidationPref').value) || 1) : 1;
            const prefType = type === 'preferred' ? row.querySelector('.prefType').value : 'non-participating';
            const capInput = row.querySelector('.cap').value;
            const cap = (type === 'preferred' && capInput !== '') ? parseNumber(capInput) : null;

            const newShareClass = {
                id: shareClasses.length > 0 ? Math.max(...shareClasses.map(sc => sc.id)) + 1 : 1,
                name,
                type,
                seniority,
                liquidationPref,
                prefType,
                cap
            };

            shareClasses.push(newShareClass);
            renderShareClasses();
            updateWaterfallAnalysis();
        }

        // Cancel share class addition
        function cancelShareClass(button) {
            const row = button.closest('tr');
            row.remove();
        }

        // Add new transaction row
        function addNewTransactionRow() {
            const row = document.createElement('tr');
            row.className = 'editing-row';
            
            const tempId = Date.now(); // Temporary ID for datalist
            
            row.innerHTML = `
                <td>
                    <select class="shareClass">
                        <option value="">Select Class</option>
                        ${shareClasses.map(sc => `<option value="${sc.name}">${sc.name}</option>`).join('')}
                    </select>
                </td>
                <td>
                    <input type="text" class="stakeholder" placeholder="Enter stakeholder name" list="stakeholder-options-new-${tempId}">
                    <datalist id="stakeholder-options-new-${tempId}">
                        ${DEFAULT_STAKEHOLDERS.map(stakeholder => 
                            `<option value="${stakeholder}">`
                        ).join('')}
                    </datalist>
                </td>
                <td><input type="text" inputmode="decimal" class="shares numeric-input" min="0" value="0"></td>
                <td><input type="text" inputmode="decimal" class="investment numeric-input" min="0" value="0"></td>
                <td class="action-buttons">
                    <button class="save" onclick="saveTransaction(this)">Save</button>
                    <button class="cancel" onclick="cancelTransaction(this)">Cancel</button>
                </td>
            `;
            
            transactionsTableBody.appendChild(row);
            attachNumericFormatting(row);
        }

        // Save transaction
        function saveTransaction(button) {
            const row = button.closest('tr');
            const shareClass = row.querySelector('.shareClass').value;
            if (shareClass === '') return;

            const stakeholder = row.querySelector('.stakeholder').value.trim();
            const shares = parseNumber(row.querySelector('.shares').value) || 0;
            const investment = parseNumber(row.querySelector('.investment').value) || 0;

            const newTransaction = {
                id: transactions.length > 0 ? Math.max(...transactions.map(tx => tx.id)) + 1 : 1,
                shareClass,
                stakeholder,
                shares,
                investment
            };

            transactions.push(newTransaction);
            renderTransactions();
            updateWaterfallAnalysis();
        }

        // Cancel transaction addition
        function cancelTransaction(button) {
            const row = button.closest('tr');
            row.remove();
        }

        // Render Sankey Diagram
        function renderSankeyDiagram(waterfallSteps, summaryData) {
            // Check if loading already failed
            if (window.d3LoadFailed) {
                showSankeyError();
                return;
            }
            
            // Check if D3 is available
            if (typeof d3 === 'undefined' || typeof d3.sankey === 'undefined') {
                console.log('D3.js or D3-Sankey not yet loaded, waiting...');
                
                // Show loading message
                const sankeyContainer = document.querySelector('.sankey-container');
                sankeyContainer.innerHTML = `
                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666; font-size: 14px;">
                        <div>
                            <div style="margin-bottom: 10px;">Loading Sankey diagram...</div>
                            <div style="width: 200px; height: 4px; background: #e5e7eb; border-radius: 2px; overflow: hidden;">
                                <div style="width: 100%; height: 100%; background: linear-gradient(90deg, #3b82f6 0%, #8b5cf6 100%); animation: loading 1.5s ease-in-out infinite;"></div>
                            </div>
                        </div>
                    </div>
                    <style>
                        @keyframes loading {
                            0% { transform: translateX(-100%); }
                            100% { transform: translateX(100%); }
                        }
                    </style>
                `;
                
                // Wait for D3 libraries to load
                if (window.d3LoadPromise) {
                    window.d3LoadPromise.then(() => {
                        console.log('D3 libraries loaded, rendering Sankey...');
                        setTimeout(() => renderSankeyDiagram(waterfallSteps, summaryData), 100);
                    }).catch((error) => {
                        console.error('Failed to load D3 libraries:', error);
                        showSankeyError();
                    });
                } else {
                    // Fallback: try again after a short delay with timeout
                    setTimeout(() => {
                        if (typeof d3 !== 'undefined' && typeof d3.sankey !== 'undefined') {
                            renderSankeyDiagram(waterfallSteps, summaryData);
                        } else if (!window.d3LoadFailed) {
                            console.log('Still waiting for D3, trying once more...');
                            setTimeout(() => {
                                if (typeof d3 !== 'undefined' && typeof d3.sankey !== 'undefined') {
                                    renderSankeyDiagram(waterfallSteps, summaryData);
                                } else {
                                    console.error('D3 loading timeout exceeded');
                                    window.d3LoadFailed = true;
                                    showSankeyError();
                                }
                            }, 3000);
                        } else {
                            showSankeyError();
                        }
                    }, 1500);
                }
                return;
            }
            
            // Clear existing diagram
            d3.select("#sankeyDiagram").selectAll("*").remove();
            
            const container = document.querySelector('.sankey-container');
            const containerRect = container.getBoundingClientRect();
            
            // Responsive margins based on screen size
            const isMobile = window.innerWidth < 768;
            const isTablet = window.innerWidth < 1024;
            
            const margin = {
                top: isMobile ? 15 : 20,
                right: isMobile ? 10 : (isTablet ? 15 : 20),
                bottom: isMobile ? 15 : 20,
                left: isMobile ? 10 : (isTablet ? 15 : 20)
            };
            
            const width = Math.max(300, containerRect.width - margin.left - margin.right);
            const height = Math.max(200, containerRect.height - margin.top - margin.bottom);
            
            // Create SVG with responsive viewBox
            const svg = d3.select("#sankeyDiagram")
                .attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
                .attr("preserveAspectRatio", "xMidYMid meet")
                .style("width", "100%")
                .style("height", "100%");
                
            const g = svg.append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

            // Create tooltip
            const tooltip = d3.select("body").append("div")
                .attr("class", "sankey-tooltip")
                .style("opacity", 0);

            // Prepare data for Sankey
            const nodes = [];
            const links = [];
            
            // Node indices
            let nodeIndex = 0;
            
            // Source node (Exit Amount)
            nodes.push({ name: "Exit Amount", id: nodeIndex++, layer: 0 });
            const exitNodeIndex = 0;
            
            // Share class nodes (Layer 1)
            const shareClassNodes = {};
            shareClasses.forEach(sc => {
                shareClassNodes[sc.name] = nodeIndex;
                nodes.push({ 
                    name: sc.name, 
                    id: nodeIndex++, 
                    layer: 1,
                    type: sc.type,
                    shareClass: sc
                });
            });
            
            // Transaction nodes (Layer 2) - Individual transactions within each share class
            const transactionNodes = {};
            transactions.forEach(tx => {
                const txKey = `${tx.shareClass}_tx_${tx.id}`;
                transactionNodes[txKey] = nodeIndex;
                let stakeholderName = 'Unknown';
                if (tx.stakeholder) {
                    const base = tx.stakeholder.split(' ')[0];
                    let role = '';
                    const match = tx.stakeholder.match(/\((.*?)\)/);
                    if (match && match[1]) role = ` ${match[1]}`;
                    stakeholderName = `${base}${role}`;
                }
                nodes.push({ 
                    name: `${stakeholderName}`, 
                    id: nodeIndex++, 
                    layer: 2,
                    transaction: tx,
                    shareClassName: tx.shareClass
                });
            });
            
            // Distribution mechanism nodes (Layer 3)
            const distributionNodes = {};
            const distributionTypes = ['Liquidation Preference', 'Participation', 'Common Distribution'];
            distributionTypes.forEach(type => {
                distributionNodes[type] = nodeIndex;
                nodes.push({ 
                    name: type, 
                    id: nodeIndex++, 
                    layer: 3,
                    distributionType: type
                });
            });
            
            // Final distribution nodes (Layer 4)
            const finalNodes = {};
            summaryData.forEach(summary => {
                if (summary.payout > 0) {
                    finalNodes[summary.name] = nodeIndex;
                    nodes.push({ 
                        name: `${summary.name} Final`, 
                        id: nodeIndex++, 
                        layer: 4,
                        finalAmount: summary.payout
                    });
                }
            });

            // Create links from Exit Amount to Share Classes
            shareClasses.forEach(sc => {
                const scSummary = summaryData.find(s => s.name === sc.name);
                if (scSummary && scSummary.payout > 0) {
                    links.push({
                        source: exitNodeIndex,
                        target: shareClassNodes[sc.name],
                        value: scSummary.payout
                    });
                }
            });

            // Create links from Share Classes to Individual Transactions
            transactions.forEach(tx => {
                const txKey = `${tx.shareClass}_tx_${tx.id}`;
                const scSummary = summaryData.find(s => s.name === tx.shareClass);
                
                if (scSummary && scSummary.payout > 0) {
                    // Calculate transaction's share of the total payout for this share class
                    const totalSharesInClass = transactions
                        .filter(t => t.shareClass === tx.shareClass)
                        .reduce((sum, t) => sum + t.shares, 0);
                    
                    const transactionPortion = totalSharesInClass > 0 ? 
                        (tx.shares / totalSharesInClass) * scSummary.payout : 0;
                    
                    if (transactionPortion > 0) {
                        links.push({
                            source: shareClassNodes[tx.shareClass],
                            target: transactionNodes[txKey],
                            value: transactionPortion
                        });
                    }
                }
            });

            // Create links from Transactions to Distribution Types
            const distributionData = {};
            const transactionDistributionData = {};
            
            waterfallSteps.forEach(step => {
                if (step.shareClass && !step.isStarting && !step.isFinal && step.value < 0) {
                    const match = step.name.match(/\((.*?)\)/);
                    if (match) {
                        let type = match[1];
                        if (type === "Liquidation Preference") {
                            type = "Liquidation Preference";
                        } else if (type.includes("Participation") || type === "Additional Participation") {
                            type = "Participation";
                        } else if (type.includes("Common")) {
                            type = "Common Distribution";
                        } else {
                            return; // Skip unknown types
                        }
                        
                        if (!distributionData[step.shareClass]) {
                            distributionData[step.shareClass] = {};
                        }
                        if (!distributionData[step.shareClass][type]) {
                            distributionData[step.shareClass][type] = 0;
                        }
                        distributionData[step.shareClass][type] += Math.abs(step.value);
                    }
                }
            });

            // Distribute the distribution amounts across transactions proportionally
            transactions.forEach(tx => {
                const txKey = `${tx.shareClass}_tx_${tx.id}`;
                const totalSharesInClass = transactions
                    .filter(t => t.shareClass === tx.shareClass)
                    .reduce((sum, t) => sum + t.shares, 0);
                
                if (totalSharesInClass > 0 && distributionData[tx.shareClass]) {
                    const transactionProportion = tx.shares / totalSharesInClass;
                    
                    Object.keys(distributionData[tx.shareClass]).forEach(distType => {
                        const value = distributionData[tx.shareClass][distType] * transactionProportion;
                        if (value > 0) {
                            links.push({
                                source: transactionNodes[txKey],
                                target: distributionNodes[distType],
                                value: value
                            });
                        }
                    });
                }
            });

            // Add links from distribution mechanisms to final amounts
            Object.keys(distributionData).forEach(shareClassName => {
                const totalForClass = Object.values(distributionData[shareClassName]).reduce((sum, val) => sum + val, 0);
                if (totalForClass > 0 && finalNodes[shareClassName] !== undefined) {
                    Object.keys(distributionData[shareClassName]).forEach(distType => {
                        const value = distributionData[shareClassName][distType];
                        if (value > 0) {
                            links.push({
                                source: distributionNodes[distType],
                                target: finalNodes[shareClassName],
                                value: value
                            });
                        }
                    });
                }
            });

            // Create Sankey layout with responsive parameters
            const nodeWidth = isMobile ? 8 : (isTablet ? 10 : 12);
            const nodePadding = isMobile ? 5 : (isTablet ? 6 : 8);
            
            const sankey = d3.sankey()
                .nodeId(d => d.id)
                .nodeWidth(nodeWidth)
                .nodePadding(nodePadding)
                .extent([[1, 5], [width - 1, height - 5]]);

            const { nodes: sankeyNodes, links: sankeyLinks } = sankey({
                nodes: nodes.map(d => ({ ...d })),
                links: links.map(d => ({ ...d }))
            });

            // Enhanced color scale
            const colorScale = d3.scaleOrdinal()
                .domain(['preferred', 'common', 'Liquidation Preference', 'Participation', 'Common Distribution', 'transaction'])
                .range(['#3b82f6', '#8b5cf6', '#ef4444', '#10b981', '#6b7280', '#f59e0b']);

            // Draw links
            g.append("g")
                .selectAll("path")
                .data(sankeyLinks)
                .join("path")
                .attr("d", d3.sankeyLinkHorizontal())
                .attr("stroke", d => {
                    if (d.source.layer === 0) return '#94a3b8'; // Exit amount
                    if (d.source.layer === 1) return colorScale(d.source.type || 'common'); // Share classes
                    if (d.source.layer === 2) return colorScale('transaction'); // Transactions
                    if (d.source.layer === 3) return colorScale(d.source.distributionType); // Distribution types
                    return '#94a3b8';
                })
                .attr("stroke-width", d => Math.max(1, d.width))
                .style("mix-blend-mode", "multiply")
                .attr("class", "sankey-link")
                .on("mouseover", function(event, d) {
                    const percentage = ((d.value / exitAmount) * 100).toFixed(1);
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    
                    let flowDescription = "";
                    if (d.source.layer === 0) flowDescription = "Exit proceeds to share class";
                    else if (d.source.layer === 1) flowDescription = "Share class to transaction";
                    else if (d.source.layer === 2) flowDescription = "Transaction to distribution mechanism";
                    else if (d.source.layer === 3) flowDescription = "Distribution mechanism to final payout";
                    
                    tooltip.html(`
                        <strong>${d.source.name}  ${d.target.name}</strong><br/>
                        ${flowDescription}<br/>
                        Amount: $${d.value.toLocaleString()}<br/>
                        Percentage: ${percentage}%
                    `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Draw nodes
            g.append("g")
                .selectAll("rect")
                .data(sankeyNodes)
                .join("rect")
                .attr("x", d => d.x0)
                .attr("y", d => d.y0)
                .attr("height", d => d.y1 - d.y0)
                .attr("width", d => d.x1 - d.x0)
                .attr("fill", d => {
                    if (d.layer === 0) return '#1e293b'; // Exit amount
                    if (d.layer === 1) return colorScale(d.type || 'common'); // Share classes
                    if (d.layer === 2) return colorScale('transaction'); // Transactions
                    if (d.layer === 3) return colorScale(d.distributionType); // Distribution types
                    if (d.layer === 4) return colorScale(d.name.split(' ')[0]); // Final amounts
                    return '#94a3b8';
                })
                .attr("class", "sankey-node")
                .on("mouseover", function(event, d) {
                    let content = `<strong>${d.name}</strong><br/>`;
                    if (d.layer === 0) {
                        content += `Total Exit Amount: $${exitAmount.toLocaleString()}`;
                    } else if (d.layer === 1 && d.shareClass) {
                        content += `Share Class Type: ${d.shareClass.type}<br/>`;
                        if (d.shareClass.type === 'preferred') {
                            content += `Liquidation Pref: ${d.shareClass.liquidationPref}x<br/>`;
                            content += `${d.shareClass.prefType}`;
                            if (d.shareClass.cap) content += ` (${d.shareClass.cap}x cap)`;
                        }
                        const totalShares = transactions
                            .filter(t => t.shareClass === d.shareClass.name)
                            .reduce((sum, t) => sum + t.shares, 0);
                        content += `<br/>Total Shares: ${totalShares.toLocaleString()}`;
                    } else if (d.layer === 2 && d.transaction) {
                        content += `Transaction Details:<br/>`;
                        content += `Shares: ${d.transaction.shares.toLocaleString()}<br/>`;
                        content += `Investment: $${d.transaction.investment.toLocaleString()}<br/>`;
                        const pricePerShare = d.transaction.shares > 0 ? d.transaction.investment / d.transaction.shares : 0;
                        content += `Price/Share: $${pricePerShare.toFixed(2)}`;
                    } else if (d.layer === 3) {
                        content += `Distribution Mechanism<br/>`;
                        content += `Used across all applicable transactions`;
                    } else if (d.layer === 4) {
                        content += `Final Payout: $${d.finalAmount.toLocaleString()}<br/>`;
                        const percentage = ((d.finalAmount / exitAmount) * 100).toFixed(1);
                        content += `Percentage of Total: ${percentage}%`;
                    }
                    
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(content)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });

            // Add node labels with responsive sizing
            const labelOffset = isMobile ? 4 : 6;
            const baseFontSize = isMobile ? 9 : (isTablet ? 10 : 12);
            const smallFontSize = isMobile ? 8 : (isTablet ? 9 : 10);
            
            g.append("g")
                .selectAll("text")
                .data(sankeyNodes)
                .join("text")
                .attr("x", d => d.x0 < width / 2 ? d.x1 + labelOffset : d.x0 - labelOffset)
                .attr("y", d => (d.y1 + d.y0) / 2)
                .attr("dy", "0.35em")
                .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
                .attr("class", "sankey-text")
                .text(d => {
                    if (d.layer === 0) return `$${(exitAmount/1000000).toFixed(1)}M`;
                    if (d.layer === 2 && d.transaction) {
                        // Responsive text based on screen size
                        if (isMobile) {
                            // On mobile, show shorter labels
                            const shareText = d.transaction.shares >= 1000000 ? 
                                `${(d.transaction.shares/1000000).toFixed(1)}M` : 
                                `${(d.transaction.shares/1000).toFixed(0)}K`;
                            return shareText;
                        } else {
                            const shareText = d.transaction.shares >= 1000000 ? 
                                `${(d.transaction.shares/1000000).toFixed(1)}M` : 
                                d.transaction.shares.toLocaleString();
                            return `${shareText} shares`;
                        }
                    }
                    if (d.layer === 4) return `$${(d.finalAmount/1000000).toFixed(1)}M`;
                    
                    // Truncate long names on mobile
                    if (isMobile && d.name.length > 12) {
                        return d.name.substring(0, 10) + "...";
                    }
                    return d.name;
                })
                .attr("fill", "#374151")
                .style("font-size", d => d.layer === 2 ? `${smallFontSize}px` : `${baseFontSize}px`);

            // Clean up tooltip on destruction
            window.addEventListener('beforeunload', () => {
                tooltip.remove();
            });
        }

        // Show error message when Sankey diagram fails to load
        function showSankeyError() {
            const sankeyContainer = document.querySelector('.sankey-container');
            sankeyContainer.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #ef4444; font-size: 14px; text-align: center;">
                    <div>
                        <div style="margin-bottom: 10px;"> Sankey diagram unavailable</div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                            D3.js libraries failed to load. This may be due to:<br>
                             Content Security Policy restrictions<br>
                             Network connectivity issues<br>
                             CDN availability problems
                        </div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 15px;">
                            The other charts and waterfall analysis are still fully functional.
                        </div>
                        <button onclick="location.reload()" style="margin-top: 10px; padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                             Retry Page
                        </button>
                    </div>
                </div>
            `;
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
<div style="max-width:1200px;margin:0 auto;padding:0 20px 30px 20px;">
    <p style="text-align:center; color:#64748b; font-size:14px;">
         Have an idea to improve this tool? <a href="https://forms.gle/QzKyMR5wFdhb4Enu5" target="_blank" rel="noopener noreferrer">Share feedback</a>
    </p>
</div>
</body>
</html> 